V priponskem polju so shranjene pripone besede $T$, ki so urejene v leksikografskem vrstnem redu, zato je najbolj učinkovita metoda iskanja bisekcija. Z bisekcijo je potrebnih $O(\log{n})$ primerjav med sredinsko pripono trenutnega intervala, na katerem se izvaja bisekcija, ter vzorcem $P$, torej je potrebno $O(m\log{n})$ časa za preveriti, ali je vzorec $P$ prisoten v besedi $T$. Ta način iskanja je $O(\log{n})$-krat počasnejši od iskanja v priponskem drevesu. To razliko si želimo znižati, pri tem pa ne želimo shraniti celotne topologije drevesa, ampak zgolj informacije, ki pospešijo iskanje po priponskem polju. V tem podpoglavju bo predstavljena predstavljen podatkovna struktura \textit{LCP}-polje. V podpoglavju \ref{sec:SAPoizvedbe} pa bo predstavljena uporab te podatkovne strukture za iskanje po priponskem polju.

Polje najdaljših skupnih predpon (angl. \textit{Longest common prifix} oziroma LCP) hrani v vsaki celici 
    $$\textit{LCP}[i,j]=lcp(T[SA[i],n],T[SA[j],n]),$$
kar je dolžina predpone, ki je skupna obema priponama. Za tako definirano $LCP$-polje je potrebno $O(n^2)$ prostora. Pri tem velika večina celic ne bo nikoli uporabljena pri bisekciji. V vsakem koraku bisekcije se preverja, ali je vzorec večji od sredinske točke $M$ na intervalu $[L,R]$. Torej za vsak možen interval bisekcije je dovolj, da se hrani dolžina najdaljše predpone med $M$ in $L$ ter med $M$ in $R$. Ker je vsaka pripona srednja točka natanko enega intervala v bisekciji, potem potrebujemo dve \textit{LCP}-polji, in sicer prvega za shraniti dolžina najdaljše predpone med $M$ in $L$, ki ga imenujemo \textit{L-LCP}, in drugega za shraniti dolžina najdaljše predpone med $M$ in $R$, ki ga imenujemo \textit{R-LCP}. Primer teh dveh polj je prikazan na Sliki \ref{fig:RlcpLlcpSuffuxArray}, na kateri je prikazano tudi drevo sredinskih točk bisekcije \cite{Manber1990}. 

\begin{figure}[htb] 
    \includesvg[scale=.8]{Slike/LLCP_RLCP.svg}
    \centering
    \caption{Primer \textit{L-LCP} in \textit{R-LCP} polji za priponskega polja nad besedo \enquote{KOKOŠ$\$$}.} 
    \label{fig:RlcpLlcpSuffuxArray}
\end{figure}

Prostorska zahtevnost te implementacije \textit{LCP} polja je $O(n)$. Če želimo biti bolj natančni \textit{L-LCP} in \textit{R-LCP} polji hranita vsak $n$ \enquote{celih števil}, torej skupaj s priponskim poljem potrebujejo $3n$ \enquote{celih števil}, kaj je še vedno $2$- do $5$-krat manj prostora kot priponsko drevo.

\subsection{Simulacija priponskega drevesa}\label{sec:STsimulacija}
V priponskem drevesu je dolžina najdaljše skupne predpone dveh pripon dolžina podniza najglobijega skupnega predhodnika (angl. \textit{Lowest common ancestor} oziroma LCA) obeh listov, ki predstavljata priponi. Ampak trenutna implementacija \textit{LCP}-polja je namenjena pospešitvi iskanja po priponskem polju in uporablja \textit{L-LCP} in \textit{R-LCP} polji. Zato se potrebuje bolj splošno \textit{LCP}-polje, ki bi nadomestilo \textit{L-LCP} in \textit{R-LCP} polji in bi omogočalo simuliranje priponskega drevesa.

Vrednost v \textit{L-LCP}$[M]$ predstavlja dolžno najdaljše skupne predpone $lcp(T[SA[M], n]$ $,T[SA[L], n])$, pri čemer je $L$ začetni indeks intervala bisekcije s sredinsko točko v $M$, in vrednost funkcije $lcp$ označimo kot $k$. Vemo tudi, da je $SA[L]<SA[M]$, torej imajo vse pripone na intervalu med $L$ in $M$ paroma najdaljšo skupno predpono dolžine vsaj $k$, saj vse pripone na tem intervalu so leksikografsko večje od $SA[L]$ in manjše od $SA[M]$. To pomeni, da za vsak $i$, ki je $L<i\le M$, velja $k\le lcp(T[SA[i-1], n], T[SA[i], n])$. Posledično obstaja tak $i$, za katerega velja $lcp(T[SA[i-1], n], T[SA[i], n])=k$. Podoben sklep se lahko naredi tudi za \textit{R-LCP}$[M]$, pri čemer uporabimo interval v priponskem polju med $M$ in $R$. Zato se lahko naredi bolj spološno $LCP$ polje $LCP[2,n]$, za katerega velja
$$
    LCP[i]=lcp(T[SA[i-1], n], T[SA[i], n]).
$$
Primer takega $LCP$ polja je prikazan na Sliki \ref{fig:SuffuxArray}. Na sliki je označena z zeleno barvo vrednost $LCP[3]$, ki je najdaljša skupna predpona med priponama $SA[2]$ in $SA[3]$. Ta vrednost je tudi označena na priponskem drevesu na sliki \cite{Abouelhoda2004, Kasai2001}.

Novo $LCP$ polje potrebuje zgolj $O(n)$ \enquote{celih števil}. Pri tem pa potrebuje dodatno podatkovno strukturo za učinkovito iskanje najmanjše vrednosti na intervalu oziroma $rmq$, ki je potrebna za nadomestiti \textit{L-LCP} in \textit{R-LCP} polji. Prva možnost je izgradnja $rmM$-drevesa, ki v vsakem vozlišču vsebuje zgolj vrednost $m$. Iskanje v drevesu pa potrebuje $O(\log{n})$ časa oziroma $O(m\log{n}+\log{n})$ časa za poizvedbo, kar pa je prepočasno, saj potrebuje iskanje z \textit{L-LCP} in \textit{R-LCP} polji $O(m+\log{n})$ časa za poizvedbo. Zato lahko uporabimo $rmq$ strukturo, ki sta jo predlagala Fischer in Heun \cite{Fischer2007}. Predlagana podatkovna struktura potrebuje $O(n)$ dodatnega prostora in za dani interval vrne najmanjšo vrednost v $O(1)$ času, torej se lahko poizvedba izvrši v $O(m+\log{n})$.

Posplošeno $LCP$ polje se tudi lahko uporabi simuliranje priponskega drevesa. Vrednost $LCP[i]$ predstavlja črkovno dolžino vozlišča $v$, za katerega velja $v=LCA(l_{i-1},l_i)$, pričemer $l_i$ predstavlja pripono $SA[i]$ in $l_{i-1}$ predstavlja pripono $SA[i-1]$. Kasai idr. \cite{Kasai2001} so uporabili to dejstvo za simulacijo pregleda od spodaj navzgor (angl. \textit{Bottom-Up Traversal}) in od desne proti levi (angl. \textit{Post-Order Traversal}). S takim obhodom drevesa lahko rešimo problem sprehoda po podnizih (angl. \textit{substring traversal problem}), ki oštevilči vse ponavljajoče se podnize. Podani algoritem potrebuje $O(n)$ časa in potrebuje enako časa kot obhod priponskega drevesa z $n$-timi listi.

V splošnem vsako notranje vozlišče $v$ v priponskem drevesu predstavlja podniz besede dolžine $l$, s katerim se začnejo vse pripone predstavljene z listi v poddrevesu s korenom v $v$. Ker je priponsko polje ekvivalentno listom priponskega drevesa, so vsi listi poddrevesa s korenom v $v$ ekvivalentni intervalu priponskega polja $SA[L,R]$, pri čemer pripona $SA[L]$ je predstavljena s skrajno levim listom in $SA[R]$ je predstavljena s skrajno desnim listom v poddrevesu. Torej so vse vrednosti intervala $LCP[L+1,R]$ vsaj $l$. Pri tem velja tudi, da pripona $SA[L-1]$ in pripona $SA[R+1]$ se zagotovo razlikujeta s priponami $SA[L]$ in $SA[R]$ vsaj v $l$-tem znaku, sicer bi bile v poddrevesu. Torej velja $LCP[L]\le l$ in $LCP[R+1]\le l$. Torej lahko imenujem tak interval $[L,R]$ $l$-interval, ki je definiran s sledečo definicijo \cite{Abouelhoda2004}.
\begin{defi}
    Interval $[i,j]$ je $l$-interval v LCP polju, natanko tedaj ko velja:
    \begin{enumerate}
        \item \textit{LCP}$[i]<l$,
        \item obstaja vsaj en $k$, za katerega velja, da je $i< k< j$ in \textit{LCP}$[k]=l$,
        \item za vsak $k$ velja, da je $i< k< j$ in \textit{LCP}$[k]\ge l$
        \item \textit{LCP}$[j+1]<l$.      
    \end{enumerate}
\end{defi}

Koren drevesa predstavlja prazen niz in njegovo poddrevo je celotno drevo, zato koren predstavlja $0$-interval $[1,n]$. Ker pa je $LCP$ polje definirano zgolj za indekse od $2$ do $n$, se lahko definira indeksa $1$ in $n+1$ kot $LCP[1]=-1$ in $LCP[n+1]=-1$. Ta popravek ne vpliva na pravilnost delvanja priponskega polja, saj ne obstaja ta priponi $SA[0]$ in $SA[n+1]$. Znotrja vsakega $l$-intervala $[L,R]$ lahko obstajajo drugi $l'$-intervali, za katere velja $l<l'$. Takih $l'$-intervalov je največ $n_l+1$, pri čemer je $n_l$ število ponovitev vrednosti $l$ v $LCP$ polju na intervalu $[L,R]$. Torej lahko predstavimo relacijo med $l$-intervali kot $LCP$ intervalno drevo (angl. \textit{LCP interval tree}). Primer LCP intervalnega drevesa je prikazan na Sliki \ref{fig:intervalTree} \cite{Abouelhoda2004}.

\begin{figure}[htb]
    \begin{subfigure}[T]{0.45\linewidth}        
        \includesvg[scale=1]{Slike/McCreigov/KOKOŠMcCreightS.svg}
        \centering
        \subcaption*{}
        \label{fig:aSADrevo}
    \end{subfigure}
    \hspace{0.5cm}
    \begin{subfigure}[T]{0.45\linewidth}        
        \includesvg[scale=0.7]{Slike/IntervalnoDrevo.svg}
        \centering
        \subcaption*{}
        \label{fig:aSAPolje}
    \end{subfigure}

    \caption{Primer intervalnega drevesa nad priponskim poljem in LCP poljem besede \enquote{KOKOŠ$\$$}. Na sliki je dodano tudi priponsko drevo besede\enquote{KOKOŠ$\$$}.} 
    \label{fig:intervalTree}
\end{figure}

Vsak vozlišče v $LCP$ intervalnem drevesu predstavlja en $l$-inerval, ki predstavlja eno notranje vozlišče priponskega drevesa. Pri tem velja, da vozlišče, ki je predstavljeno z $l$-intervalom $[L,R]$, ima črkovno globino $l$ in skrajno levi list v poddrevesu predstavlja pripono $SA[L]$ ter skrajno desni list v poddrevesu pa predstavlja pripono $SA[R]$. Torej $LCP$ intervalno drevo predstavlja notranja vozlišča priponskega drevesa, pri čemer $l$-interval $[l,R]$ vozlišča v $LCP$ intervalnem dreveseu predstavlja seznam vseh listov poddrevesa vozlišča v priponskem drevesu, ki predstavlja podniz $T[SA[L],SA[L]+l]$ dolžine $l$. Na Sliki \ref{fig:intervalTree} je jasno vidna ta relacija med priponskim drevesom in $LCP$ intervalnim drevesom.

Za učinkovito simulacijo priponskega drevesa je potrebno učinkovito shraniti $LCP$ intervalno drevo. To se lahko stori s tremi dodatnimi polji dolžine $n$ \enquote{celih števil}, torej potrebujemo $5n$ \enquote{celih števil}. Pri tem ni potreben $rmq$ podatkovne strukture, saj se lahko z uporabo $l$-intervalov išče po prionskem polju na enak način kot po priponskem drevesu in pri tem potrebujemo zgolj med $1,4$- in $2$-krat manj prostora kot ekvivalentno priponsko drevo. Ta tri dodata polja dolžine $n$ se uporabi za shranjevanje indeksov začetka intervala v $LCP$ intervalnem drevesu: gor $G[1,n]$, dol $D[1,n]$ (indeksi prve ponovitve vrednosti $l$ v $l$-intervalih) in naslednji indeks $NI[1,n]$ (indeksi naslednjih vrednosti $l$ v $l$-itervalih). Na ta način se lahko sprehodimo po intervalnem drevesu, kar omogoča simulacijo sprehoda po priponskem drevesu. Sprehod se začne z indeksom 1, ki predstavlja prvega otroka korena $LCP$ intervalnega drevesa \cite{Abouelhoda2004}.

Simulacija priponskega drevesa z uporabo priponskega polja in $LCP$ polja ter $l$-intervalov omogoča znižanje časa poizvedbe \textit{številoPonovitev}$(T,P)$. V priponskem drevesu ta poizvedba potrebuje $O(m+occ)$ časa, saj je potrebno prešteti število listov v poddrevesu. Z uporabo simulacije priponskega drevesa tega štetja ni potrebno storiti, saj poznamo velikost intervala, ki ga pokriva vozlišče, ki je koren poddrevesa. Število pripon je na tako razlika med začetkom in koncem interval, pri čemer konec intervala je začetek naslednjega intervala, ki je shranjen v polju $NI$. Poizvedba \textit{seznamPojavov}$(T,P)$ še vedno potrebuje $O(m+occ)$ časa, ker se je potrebno sprehoditi po priponskem polju. Če se iskani interval začne na mestu $i$, so vse pripone, ki so del intervala, v priponskem polju $SA[i, NI[i]-1]$ in za narediti seznam vseh pripon se potrebuje $NI[i]-i=O(occ)$ časa.
