Podobno kot priponsko drevo, je mogoče izgraditi priponsko polje za besedo $T$ dolžine $n$ z različnimi algoritmi. Časovna zahtevnost teh algoritmov je med $O(n^2\log{n})$ in $O(n)$. Algoritmi bodo predstavljeni od najbolj neučinkovitega do najbolj učinkovitega.

\paragraph{Izgradnja s priponskim drevesom:}
Priponsko polje je ekvivalentno listom priponskega drevesa, zato se lahko uporabi priponsko drevo za izgraditi priponsko polje. Priponsko polje je zgrajeno v dveh korakih:
\begin{enumerate}
    \item izgradnja priponskega drevesa z $O(n)$ algoritmom, recimo z Ukkonenovim algoritmom (korak ni potreben če je priponsko drevo že izgrajeno),
    \item sprehod v globino po drevesu in zapis indeksov pripon iz listov v polje v vrstnem redu obiska.
\end{enumerate}
V koraku sprehoda je mogoče izgraditi tudi $LCP$ polje. Vrednosti v $LCP$ polju so črkovne dolžine vozlišč, ki so najgloblji predhodnik dveh zaporednih listov. V teh vozliščih se obrne smer sprehoda, saj do takrat je sprehod poteka od lista navzgor in se je v vozlišču obrnil ter poteka od vozlišča do lista navzdol.

Opisan algoritem izgradi priponsko polje in $LCP$ polje v $O(n)$ časa. Vsak korak potrebuje $O(n)$ časa, saj smo izbrali algoritem za izgradnjo priponskega drevesa s časovno zahtevnostjo $O(n)$ in sprehod po drevesu z $O(n)$ vozlišči potrebuje $O(n)$ časa. Pri tem pa algoritem potrebuje 5-krat več dodatnega prostora, kot ga zasede priponsko polje, in razlog za izgradnjo priponskega polje je zmanjšanje količine spomina, ki ga zasede indeks besedila. Zato bi potrebovali algoritem, ki izgradi priponsko polje v $O(n)$ časa in ne izgradi priponskega drevesa.

\paragraph{Izgradnja s urejanjem pripon:}
Priponsko polje je polje indeksov pripon urejenih v leksikografskem vrstnem redu, zato se lahko uporabi urejanje za izgradnjo priponskega polja. Najbolj učinkoviti algoritmi za urejenaje (\textit{Quck sort} oziroma \textit{Merge sort}) potrebujejo $O(n\log{n})$ primerjav za izgradnjo priponskega polja. Ker so pripone urejene leksikografsko, vsaka primerjava potrebuje $O(n)$ časa, torej celotna izgradnja potrebuje $O(n^2\log{n})$ časa. Pri tem se potrebuje še dodatnega $O(n)$ časa za izgradnjo $LCP$ polja, saj je potrebno izračunati vse $lcp$ vrednosti zaporednih pripon \cite{Kasai2001}.

Namesto tega lahko uporabimo korensko urejanje (angl. \textit{RadixSort}). Torej v $i$-tem koraku korenskega urejanja so pripone urejene v vedrih glede na prvih $i$ znakov. To dejstvo se lahko uporabi za izgradnjo $LCP$ polja, saj se v $i$-tem koraku lahko zapiše vrednost $i$ na začetek vsakega na novo ustvarjenega vedra. Korensko urejanje potrebuje $O(kn)$ časa, pri čemer je $k$ dolžina korena, in v najslabšem primeru je $k=n$, torej metoda potrebuje $O(n^2)$ časa.

Namesto da se v vsakem koraku podaljša koren za en znak, se lahko koren podvoji. Na ta način potrebuje korensko urejanje $O(\log{n})$ korako in posledično se potrebuje $O(n\log{n})$ časa za izgradnjo priponskega polja. Pri tem pa vrednost v $LCP$ polju na začetku vskaega na novo ustvarjenega vedra ni enaka številu že opravljenih korakov, ampak je v intervalu med $2^{i-1}$ in $2^{i}$, pri čemer je $i$ število že opravljenih korakov urejanja. Torej je potrebno poiskati natančno vrednost znotraj intervala s primerjavo znakov, pri tem pa ni potrebno primerjati prvih $2^{i-1}$ znakov. Algoritem potrebuje $O(n)$ dodatnega prostora, in sicer 3 polja \enquote{celih števil} in 2 bitni polji dolžine $n$ \cite{Manber1990}.

Z boljšo hevristiko lahko znižamo čas izgranje na $O(n)$ brez priponskega drevesa\cite{Ko2005}


