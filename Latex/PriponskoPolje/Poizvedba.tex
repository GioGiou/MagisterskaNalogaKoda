Priponsko polje je bilo izgrajeno kot alternativa priponskemu drevesu, ki potrebuje manj prostora. Zato se ga indeksiranje besede $T$ in posledično iskanje vzorcev v njej. V tem podpoglavju bodo predstavljene implementacije istih poizved kot za priponsko polje jih uporablja v priponskem drevesu.

Najbolj osnovna poizvedba, ki bo uporabljena kot osnova za ostali deve poizvedbi, je \textit{prisotnost}$(T,P)$. Pisotnost vzorca $P$ v besedilu $T$ lahko preverimo s bisekcijo, saj so pripone v priponskem polju urejene. V vsakem koraku bisekcije preverimo, ali se pripona na sredini interval $[L,R]$, v prvem koraku je $L=1$ in $R=n$, ujema z vzorcem $P$, pri čemer označimo indeks te pripone kot $M$. Če je $T[SA[M],SA[M]+m]=P$ potem je vzorec $P$ prisoten v besedilu $T$, sicer pa obstaja tak $k$, za katerega velja $P[k]\ne T[SA[M]+k]$. V tem primeru obstajata dve moznosti: $P[k]<T[SA[M]+k]$ in zato nadaljujemo z iskanjem v intervalu $[L,M]$ ali pa $P[k]>T[SA[M]+k]$ in se nadaljuje z iskanjem v intervalu $[M,R]$. Postopek se nadaljuje dokler $R-L>1$, ko je $R-L=1$ in $P[k]\ne T[SA[M]+k]$ potem $P$ in prisoten v besedi $T$. Tako opisan postopek potrebuje $O(m\log{n})$ časa, saj bisekcija potrebuje $O(\log{n})$ primerjav, vsaka primerjava pa potrebuje dodatnik $O(m)$ primerjav, da ugotovimo ali se pripona in vzorec ujemata.

V predhodnjem podpoglavju je bila predstavljena podatkovna struktura $LCP$ polje, ki se jo lahko uporabi za pospešiti iskanje, in sicer implementacija z polji \textit{L-LCP} in \textit{R-LCP}. Poizvedba z $LCP$ polji še vedno temelji na bisekciji, saj bisekcija je najbolj učinkovit način iskanja po urejenme polju. V osnovni različici poizvedbe vsakem koraku bisekcije preverimo ali je vzorec manjši, večji ali enak srednji priponiintervala $[L,R]$ z indeksom $M$. Pri tem lahko prešetjemo, koliko zanakov se ujema med pripono $SA[M]$ in $P$ ter označimo to vrednost s $k$. To zanje lahko uporabimo za znižati število primerjav črk $P$ in $SA[M]$ na $O(m)$ skozi celotno izvajanje bisekcije. Torej na začetku vsakega koraka vemo, da se $P$ ujema z vsaj $k$ znaki in če smo v levem oziroma desnem podintervalom predhodnega intervala. Recimo da smo v desnem, torej $L$ je bila predhodnja sredinska točka. Vemo da se $P$ in $SA[L]$ ujemata v $k$ znakih ter $SA[L]$ in $SA[M]$ se ujemata v \textit{L-LCP}$[SA[M]]$ in pripona $SA[L]$ je leksikografsko manjša od $SA[M]$. Torej obstajajo tri moženosti:
\begin{enumerate}
    \item $k<\textit{L-LCP}[M]$, potem se priponi $SA[L]$ in $SA[M]$ bolj ujemata kot pripona $SA[L]$ in $P$. Ker smo v desnem v predhonjem koraku izvedeli, da je $P$ večji od sredne predhonjega interval, pomeni, da je $P[k+1]>T[SA[L+k+1]]=T[SA[M+k+1]]$.Torej naslednji pregledani interval je $[M,R]$.
    \item $k>\textit{L-LCP}[M]$, potem se priponi $SA[L]$ in $SA[M]$ manj ujemata kot pripona $SA[L]$ in $P$ in označimo \textit{L-LCP}$[M]=l$. Torej $P[l+1]=T[SA[L+l+1]]<T[SA[M+l+1]]$, saj je $L<M$, ker je $SA[L]$ leksikografsko manjša $SA[M]$. Torej se bisekcija nadaljuje na intervalu $[L,M]$.
    \item $k=\textit{L-LCP}[M]$, potem je potrebno prevriti, ali je $P$ večji od $SA[M]$. Pri tem ni potrebno preveriti prvih $k$ zankov, saj vemo, da se ujemajo, ker je se pripona $SA[L]$ ujema $SA[M]$ v $k$ znakih in $SA[L]$ se tudi ujema z $P$ v $k$ znakih. Med preverjanjem štejemo koliko zankov se ujema in to zabeležimo kot $k'$. Če je $P[k+k'+1]<T[SA[M]+k+k'+1]$ potem nadaljujemo v interval $[L,M]$, sicer je $P[k+k'+1]>T[SA[M]+k+k'+1]$ in nadaljujemo v interval $[M,R]$. Preden nadaljujemo v nasldnji interval popravimo $k\leftarrow k+k'$.
\end{enumerate}
Simetrično velja tudi če smo v levem podintervalu, pri tem pa uporabimo \textit{R-LCP}, saj je $R$ predhodnja strednja točka intervala.

Operacija \textit{prisotnost}$(T,P)$ potrebuje $O(m+\log{n})$ časa, da preveri prisotnost vzorca v besedilu. Potrebujemo $O(\log{n})$ primerjav, saj se uporablja bisekcijo za učinkovito iskanje po urejenem polju. Skozi celotno izvajanje poizvedbe pa se potrebuje dodtnega $O(m)$ časa za primerjav med znaki vzorca $P$ in zanki pripon na sredini intervalov bisekcije.


---------------------

Preostali poizvedbi sta si zelo podbni in imata isto osnovno idejo implementacije. Brez škode za splošnost lahko uporabimo poizvedbo \textit{številoPonovitev}$(T,P)$ za razložiti idejo. Vzorec se nahaja na začetku sprehoda od \textit{korena} proti listom, zato je število ponovtiev vzorca v besedi enako šetvilu listov v drevesu, katerih pot do njih se začne z vzorcem $P$. Isto velja tudi za poizvedbo \textit{seznamPojavov}$(T,P)$, pri čemer pa indeksi pripon, ki so shranjeni v listih, predstavljajo indekse v besedi, kjer se pojavi vzorec $P$.

Začetka implementacije obeh poizvedb sta enaki kot pri poizvedba \textit{prisotnost}$(T,P)$. Če je vzorec $P$ prisoten v besedilu, potem se vzorec $P$ konča na povezavi, ki vodi v vozlišče $v$. Zato velja, da so vsi listi priponskega drevesa, ki predstavljajo pripone s predpono $P$, tudi listi v poddrevesu s korenom v vozlišču $v$. Torej za najti oziroma prešteti vse ponovitve vzorca $P$ v vhodni besedi $T$, se je potreno sprehoditi po poddrevesu. Poizvedba \textit{številoPonovitev}$(T,P)$ vrne število obiskanih listov v poddrevesu s korenov v $v$, če pa vzorec $P$ ni prioten v besedi pa vrne $0$. Poizvedba \textit{seznamPojavov}$(T,P)$ pa vrne seznam vseh indeksov pripon, ki so predstavljeni z obiskanimi listi v sprehodu, če pa vzorec $P$ ni prisoten v besedi pa vrne prazen seznam $[~]$.

Časovna zahtevnost obeh poizvedb je $O(m+\textit{occ})$, pri čemer je \textit{occ} število pojavov vzorca v besedi $T$. Ker je prvo potrebno preveriti, ali je vzorec prisoten v drevesu, je potreno izvesti iste korake kot za poizvedbo \textit{prisotnost}$(T,P)$, zakar je potrebno $O(m)$ časa. Za najti vse liste v poddrevesu pa je potrebno še $O(\textit{occ})$ čas. Ker v priponskem drevesu z $n$-timi listi je $O(n)$ vozlišč, potem je v poddrevesu priposnkega drevesa z \textit{occ} listi $O(\textit{occ})$ vozlišč. Ker tako pregled v globino kot tudi pregled v širino potrebujeta v drevesih z $n$-timi vozlišči $O(n)$ časa, potem takem za najti vse liste poddrevesa potrebujemo $O(\textit{occ})$ časa.

