Iste poizvedbe kot v priposnkem drevesu



Listi priponskga drevesa predstavljajo pripone besede $T$, zato je poizvedba \textit{prisotnost}$(T,P)$ s pomočjo priponskega drvesa implementirana s sprehodom iz \textit{korena} drevesa proti listom. Ker vsaka povezava predstavlja podniz besede $T[k,p]$, ki je lahko shranjen kot par indeksov $k$ in $p$, je potrebno preveriti, ali se $P$ ujema s $T[k,p]$. Če se vzorec ne ujema s podnizom, potem vzorec ni prisoten v besedi in zato poizvedba vrne \textit{false}, sicer se ujema s podnizom, torej je vzorec prisoten v besedi in zato poizvedba vrne \textit{true}. Tako predstavljen način iskanja deluje zgolj za vzorce, ki niso daljši od $p-k$ znakov. Če pa je vzorec $P$ daljši, se najprej pogleda prvih $p-k$ znakov in če se podniza ujemata se nadljuje s iskanjem na naslednji povezavi, ki se začne v vozlišču $v$, do katerega smo prišli po povezavi $T[k,p]$, na poti proti listom. Pri tem si je potrebno zapomniti koliko znakov smo že pregledali in to označimo z $o$. V vsakem koraku povečamo $o$ za $p-k$ ter perverimo, ali je $P[o+1,o+p-k]=T[k,p]$. Poizvedba se konča na povezavi, za katero velja, da je $p-k>=m-o$, če se je vseh $o$ dotakrat pregledani znakov ujemalo. V vozlišču $v$ je izbrana povezava, za katero velja, da se prvi znak povezave ujema z znakom $P[o+1]$. Izkanje te povezave potrebuje od $O(1)$ časa (vsako vozlišče ima polje velikosti $|\Sigma|$, tako da ima vsak znak alociran prostor za svojo povezavo, čeprav otrok neobstaja) do $O(|\Sigma|)$ časa (vsako vozlišče ima povezan seznam povezav do otrok), kar je še vedno konstanten čas, saj se abeceda $\Sigma$ ne spreminja skozi postopek izgradnje in poizvedb.

Operacija \textit{prisotnost}$(T,P)$ potrebuje $O(m)$ časa, da preveri prisotnost vzorca v besedilu. Operacija more preveriti ali se vsi znaki vzorca ujemajo z znaki na povezavah, ki so del poti od \textit{korena} proti listom, za kar potrebuje $O(m)$ časa. V vsakem notranjem vozlišču na poti pa potrebuje še dodatnega $O(1)$ časa, da se najde naslednjo povezavo. Ker je notranjih vozlišč na poti največ $m$, potem tudi celotna poizvedba potrebuje $O(m)$ časa.


Preostali poizvedbi sta si zelo podbni in imata isto osnovno idejo implementacije. Brez škode za splošnost lahko uporabimo poizvedbo \textit{številoPonovitev}$(T,P)$ za razložiti idejo. Vzorec se nahaja na začetku sprehoda od \textit{korena} proti listom, zato je število ponovtiev vzorca v besedi enako šetvilu listov v drevesu, katerih pot do njih se začne z vzorcem $P$. Isto velja tudi za poizvedbo \textit{seznamPojavov}$(T,P)$, pri čemer pa indeksi pripon, ki so shranjeni v listih, predstavljajo indekse v besedi, kjer se pojavi vzorec $P$.

Začetka implementacije obeh poizvedb sta enaki kot pri poizvedba \textit{prisotnost}$(T,P)$. Če je vzorec $P$ prisoten v besedilu, potem se vzorec $P$ konča na povezavi, ki vodi v vozlišče $v$. Zato velja, da so vsi listi priponskega drevesa, ki predstavljajo pripone s predpono $P$, tudi listi v poddrevesu s korenom v vozlišču $v$. Torej za najti oziroma prešteti vse ponovitve vzorca $P$ v vhodni besedi $T$, se je potreno sprehoditi po poddrevesu. Poizvedba \textit{številoPonovitev}$(T,P)$ vrne število obiskanih listov v poddrevesu s korenov v $v$, če pa vzorec $P$ ni prioten v besedi pa vrne $0$. Poizvedba \textit{seznamPojavov}$(T,P)$ pa vrne seznam vseh indeksov pripon, ki so predstavljeni z obiskanimi listi v sprehodu, če pa vzorec $P$ ni prisoten v besedi pa vrne prazen seznam $[~]$.

Časovna zahtevnost obeh poizvedb je $O(m+\textit{occ})$, pri čemer je \textit{occ} število pojavov vzorca v besedi $T$. Ker je prvo potrebno preveriti, ali je vzorec prisoten v drevesu, je potreno izvesti iste korake kot za poizvedbo \textit{prisotnost}$(T,P)$, zakar je potrebno $O(m)$ časa. Za najti vse liste v poddrevesu pa je potrebno še $O(\textit{occ})$ čas. Ker v priponskem drevesu z $n$-timi listi je $O(n)$ vozlišč, potem je v poddrevesu priposnkega drevesa z \textit{occ} listi $O(\textit{occ})$ vozlišč. Ker tako pregled v globino kot tudi pregled v širino potrebujeta v drevesih z $n$-timi vozlišči $O(n)$ časa, potem takem za najti vse liste poddrevesa potrebujemo $O(\textit{occ})$ časa.

