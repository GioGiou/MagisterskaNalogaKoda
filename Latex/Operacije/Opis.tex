Preden se lahko izdela primerjavo podatkovnih struktur je potrebno predstaviti okolje, v katerem bo izdelana primerjava, metoda uporabljena za izdelavo testnih primerov ter sami testni primeri, ki bodo uporabljeni za izdelavo primerjave. V tem podpoglavju bodo prvo predstavljeni testni primeri, za tem bo predstavljena uporabljena testna metoda ter na koncu bo predstavljen stroj in operacijski sistem, ki je uporabljen za izdelavo testiranja. 

\subsection{Testni primeri}

Predstavljeno testno metodo bomo pognali nad dvema vhodnima besedama, ki sta prikazani v Tabeli \ref{tab:besedila}. Prva testirana beseda je Cankarjev kratki roman Na klancu \cite{podatkiNaKlancu}. Roman je bil izbran, saj predstavlja tipično vhodno besedo v naravnem jeziku, ki je v tem primeru slovenščina. Abeceda takih besed sestoji iz črk naravnega jezika (velikih in malih), presledkov in ločil. Pri tem se je pojavil problem, saj slovenščina ne uporablja ASCII znake. Zato je potrebno pred samim začetkom testiranja vhodno besedo pred pripraviti. To je bilo storjeno tako, da so bili vsi ne ASCII znaki odstranjeni oziroma zamenjani z ASCII alternativami. Na primer znak, ki predstavlja '...', je bil zamenjan s tremi pikami, vse črke z naglasi (kot so strešice, ostrivci ter drugi) so bile zamenjani z osnovnim znakom, torej na primer š postane s in é postane e. Pri tem so bile tudi odstranjene vse prazne vrstice ter ločila poglavij, ki so bila označena z '***'. Odstranjeni so bili tudi vsi nevidni simboli, ki niso vidni bralcu, prisotni v besedilu. Na ta način se je začetno besedilo znižalo iz dolžine 319843 znakov na 317803.

\begin{table}[htb]
    \caption{Primerjava besedil, ki smo jih uporabili za primerjavo različnih indeksov besed}
    \label{tab:besedila}
    \centering
    \begin{tabular}{rccc}
        Ime testne besede& Število znakov & Velikost abecede & Velikost na disku \\
        &  &   & [MB]\\
         \hline
        Ivan Cankar, Na klancu \cite{podatkiNaKlancu}& 317803 & 52 & $25,851$ \\
        DNK sekvenca \cite{podatki}&  52428800& 4 & $26,767$ \\
    \end{tabular}    
\end{table}

Druga testirana beseda pa je daljša DNK sekvenca \cite{podatki}, ki je zlepek različnih DNK sekvenc. Izbrana je bila kot primer vhodne besede, uporabljene v bioinformatiki. Ta vhodna beseda je bila predhodno uporabljena za testiranje implementacije kompaktnega priponskega drevesa od Välimäki idr. \cite{Valimaki2007}.

\paragraph{Podaljševanje besedila.}

V drugem stolpcu Tabele \ref{tab:besedila} so prikazane dolžine besed, ki bodo uporabljen za testiranje. Pri tem se opazi, da so nekatera besedila krajša kot 1024500 znakov, ki so potrebni za izgradnjo indeksov in za izdelavo vzorcev testiranja. Zato je treba te besede podaljšati. Ker je malo verjetno, da se vhodno besedilo ponovi $k$-krat, dokler ne doseže primerne velikosti, predvsem v naravnem jeziku, bo uporabljena bolj napredna metoda podaljševanja besedila. Metoda vzame manjše podnize besedila ter naredi stik med začetno besedo in podnizom. Tako dobljeno besedilo je bolj verjetno, saj je večja verjetnost, da se manjši deli besedila ponovijo za razliko od celotnega besedila. Predlagana metoda podaljševanja besedila je prikazana v Algoritmu \ref{alg:Konkatenacija}. Pri tem metoda predpostavi, da je besedilo dolgo vsaj $3000$ znakov. Ta metoda je primerna za podaljševanje daljših besedil, sicer pa je možno metodi spremeniti parameter $i$ in tako prilagoditi metodo drugim besedilom.


\begin{algorithm}[htb]

\Vhod{Vhodna beseda $T$, velikost $s_{max}$}
\Izhod{Besedilo $T_0$}
\caption{Metoda podaljševanja vhodnega besedila}\label{alg:Konkatenacija}
{
    {$T_0\leftarrow T$}

    {$i\leftarrow 500$}
    
    \While{$|T_0| < s_{max}$}{
        
        {$T_0\leftarrow T_0\cdot T[i:6i]$}
        
        
        {$i\leftarrow i+500$}

        \While{$6i>|T|$}{$i=i/4$}
        
    }
    \Vrni{$T_0[1:s_{max}]$}    
    
}
\end{algorithm}

Predlagana metoda podaljša besedo na velikost $s_{max}$. Ta velikost je lahko dolžina najdaljše besede ali pa je poljubna vrednost, bodisi manjša od dolžine največje besede bodisi večja. Če je beseda daljša od velikosti $s_{max}<|T|$, bo predlagana metoda skrajšala besedo na $|T_0|=s_{max}$. Za potrebe testiranja smo se odločili, da je $s_{max}=25000000$, kar je več kot zadostna dolžina.

\subsection{Metoda testiranja}
Strukturna primerjava je prikazana s psevdokodo na Algoritmu \ref{alg:metodaTest}. Vsak test v primerjavi se izvede petkrat, da se zmanjša vpliv drugih procesov na rezultate testiranja. Iz psevdokode opazimo, da je primerjava poizvedb  bila storjena za poizvedbo $\Prisotnost{T}{P}$, saj je pogosto vprašanje v biologiji prisotnost gena (vzorcev $P$) v DNK sekvenci (vhodna beseda $T$), ne pa natančen položaj tega gena ali števila ponovitev gena v DNK sekvenci. Poizvedba je bila izdelana za vzorce velikosti 5, 50, 500 in $\log{|T|}$ (na psevdokodi $\log{i}$). Rezultati testiranja so shranjeni v CSV datoteki in vsaka vrstica datoteke, shrani sledeče podatke: podatkovna struktura, velikost vhodne besede, čas izgradnje, čas iskanja vzorca dolžine 5, čas iskanja vzorca dolžine 50, čas iskanja vzorca dolžine 500, čas iskanja vzorca dolžine $\log{|T|}$ ter velikost podatkovne strukture. Velikost bo dodana ročno iz podatkov pridobljenih s pomnilniškim profilerjem (angl. \textit{memory profiler}). 

\begin{algorithm}[htb]

\Vhod{Vhodna beseda $T$, število znakov v najdaljšem testiranem nizu $i_{max}$}
\Izhod{CSV datoteka z izračunanimi časi}
\caption{Psevdokoda primerjave indeksov vhodne besede $T$}\label{alg:metodaTest}
{
    {$i \leftarrow 500$}
    
    \Dokler{$i \le i_{max}$}{

        \Za{$S\in\{ST, SA, SA+LCP, CST\}$}{
            \Za{$k=1,\dots,5$}{
                {$\textit{start}\leftarrow \textit{čas}()$}

                {$\textit{Izgradi}(S,T[1:i-1]\cdot\$)$}

                {$\textit{konec}\leftarrow \textit{čas}()$}

                {$t_{Izg}\leftarrow \textit{konec} - \textit{start}$}

                \Dokler{$j \le 500$}{
                    {$\textit{start}\leftarrow \textit{čas}()$}

                    {$\Prisotnost{S}{T[i:i+j]}$}

                    {$\textit{konec}\leftarrow \textit{čas}()$}

                    {$j\leftarrow j*10$}

                    {$t_{j} \leftarrow \textit{konec} - \textit{start}$}
                }

                {$j\leftarrow \log{i}$}

                {$\textit{start}\leftarrow \textit{čas}()$}

                {$\Prisotnost{S}{T[i:i+j]}$}

                {$\textit{konec}\leftarrow \textit{čas}()$}

                

                {$t_{log} \leftarrow \textit{konec} - \textit{start}$}

                {$\textit{Shrani}(S,i,t_{Izg},t_{5},t_{50},t_{500},t_{log}$)}

                {$\textit{Izbriši}(S)$}
            }
        }        
        
        {$i \leftarrow i+500$}
        
    } 
    
}
\end{algorithm}

\subsection{Stroj in operacijski sistem}
Za izdelavo primerjav podatkovnih struktur bo uporabljen računalnik s procesorjem Intel Core i3 5005U z dvema jedroma in štirimi nitmi ter s taktom $1,9$ GHz. Računalnik ima na razpolago 4 GB delovnega pomnilnika, od katerega je ob zagonu zasedenega $1,35$ GB z operacijskim sistemom ter emulatorjem terminala (angl. \textit{terminal emulator}). Poleg delovnega pomnilnika ima računalnik še $8$ GB Swap razdelka na trdem disku, ki je namenjen shranjevanju neuporabljenih pomnilniških strani v primeru prezasedenega delovnega pomnilnika in posledično sproščanju le tega. Operacijski sistem računalnika je Fedora 42 in uporabljen Linux kernel je 6.14.11-300.

Primerjava je izdelana v programskem jeziku C++\footnote{Koda je dostopna na povezavi \url{https://github.com/GioGiou/MagisterskaNalogaKoda}.}. Zato se časi, potrebni za izgradnjo struktur ter poizvedb v njih, izmerijo z beleženjem trenutnega časa pred začetkom, ki ga shranimo v spremenljivko \verb|start|, in po koncu operacije, ki ga shranimo v spremenljivko \verb|stop|. Meritve so implementirane s funkcijo \verb|high_resolution_clock::now()|, ki je del standardne knjižnice programskega jezika C++ in vrne natančen čas trenutka, v katerem je funkcija izvedena. Čas izvajanja se lahko naračuna kot razlika med časom ob koncu izvajanja in časom ob začetku izvajanja operacije, kar se v C++ stori s funkcijo \verb|duration_cast<nanoseconds>(stop - start)| \verb|.count()|. Za izgradnjo podatkovnih struktur bodo uporabljene sledeče knjižnice: za priponsko drevo je uporabljena implementacija iz knjižnice \cite{ganeshk13}, za kompaktna priponska drevesa je uporabjena implementacija iz knjižnice SDSL \cite{gbmp2014sea} in za priponska polja pa je uporabljena implementacija iz knjižnice \cite{Grebnov2025}. Le-ta zgradi priponsko polje v $O(n)$ časa z algoritmom, ki sta ga predstavila Timoshevskaya in Feng \cite{Timoshevskaya2014}. Algoritem je izboljšava predhodno predstavljenega algoritma od Ko in Aluru \cite{Ko2005}. Pri tem pa je uporabljena različica LCP polja imenovana $Q-LCP$ polje, ki je bila predstavljena v podpoglavju \ref{sec:SAPoizvedbe}.
%Knjižnica \cite{Grebnov2025} sicer podpira izgradnjo LCP strukture, ki je bila predstavljena v podpoglavju \ref{sec:STsimulacija}, ampak nima dodatne podatkovne strukture Fischer-Heun za operacijo $rmq$ v konstantnem času \cite{Fischer2007}.

Poleg časovne zahtevnosti gradnje in poizvedb v podatkovnih strukturah nas zanima, koliko prostora zasede posamična podatkovna struktura  na delovnem pomnilniku. In sicer nas zanima največji zaseden prostor v času izgradnje posamične podatkovne strukture. Le-ta bo izmerjen z uporabo pomnilniškega profilerja. Uporabljen bo pomnilniški profiler Bytehound \cite{Bytehound2024}, saj omogoča grafični prikaz porabe pomnilnika v času izvajanja programa.

Ker je primerjava izdelana v C++, je potrebno kodo prevesti v izvršljivo datoteko. To je strojeno s prevajalnikom GCC 15.1.1. Program je bil preveden s sledečim ukazom:
\begin{lstlisting}[language=bash]
    g++ -std=c++11 -O3 -DNDEBUG -I ./include -L ./lib // 
    main.cpp -o main -lsdsl -ldivsufsort //
    -ldivsufsort64 -lsuffix -lsais
\end{lstlisting}
Pri prevajanju programa je uporabljenih nekaj zastavic, ki določajo vrednosti parametrov prevajalnika. Večina zastavic je vezana na uvažanje knjižnic v prevajanje, in sicer \verb|-I ./include| nastavi pot do zaglavnih datotek (angl. \textit{header files}), \verb|-L ./lib| nastavi pot do strojne kode knjižnice ter zastavice \verb|-lsdsl|, \verb|-ldivsufsort|, \verb|-ldivsufsort64|,  \verb|-lsais| in \verb|-lsuffix| uvozijo potrebne knjižnice za izgradnjo izvršljive datoteke.
Zastavica \verb|-O3| določa nivo optimizacije izvršljive datoteke na nivo 3, ki je bil izbran, saj je uporabljen za prevajanje prve implementacije kompaktnega priponskega drevesa \cite{Valimaki2007}. Ker se uporablja profiler, je potrebo pred začetkom testiranja indeksov besed zagnati tudi profiler, kar je storjeno z ukazom:
\begin{lstlisting}[language=bash]
    export MEMORY_PROFILER_LOG=info
    LD_PRELOAD=~/bytehound/libbytehound.so ./main // 
    ./test/NaKlancu.txt 
\end{lstlisting}
Prva vrstica ukaza določa stopnjo profiliranja, ki ima v tem primeru vrednost \verb|info|, ter se jo shrani v sistemsko spremenljivko \verb|MEMORY_PROFILER_LOG|. Naslednja vrstica pa požene program ter se poda kot prvi parameter ime datoteke s testnimi podatki. Zgornji ukaz prikaže primer za vhodno besedilo Na klancu. S spremenljivko \verb|LD_PRELOAD| je določen deljeni objekt (angl. \textit{shared object}), ki je izvršen pred začetkom programa. V primeru testiranja je deljeni objekt profiler, kar mu omogoča dostop do programa in lažje beleženje zasedenega delovnega spomina.

Dolžina najdaljše vhodne besed $i_{max}$ je bila sprva nastavljena na 4000000 znakov. Med testiranjem priponskega drevesa besede dolžine 2048000 znakov se je opazilo, da čas, potreben za izgradnjo prvega priponskega drevesa, presega 5 minut. Po petih minutah od začetka gradnje drevesa lahko opazimo, da je delovni pomnilnik skoraj v celoti zaseden ter je Swap razdelek zaseden že s 6 GB pomnilniški strani. Pri tem je računalnik neodziven in proces je v neprekinjenem spanju (angl. \textit{Uninterruptible sleep} ali stanje D). Na Sliki \ref{fig:6GB} je prikazan upravljalnik opravil Htop v času izgradnje priponskega drevesa za besedo dolžine 2048000 znakov. Proces v modri vrstici predstavlja program za testiranje časa izgradnje in poizvedb ter prostorske zahtevnosti indeksov besed. V stolpcu, označenim S (Stanje ali angl. \textit{Status}), je vidno, da je je stanje procesa označeno kot D, ker je proces v neprekinjenem spanju. Po več kot 5 minutah od začetka gradnje priponskega drevesa za besedo dolžine 2048000 znakov smo se odločili, da se proces ubije. Posledično se je znižala velikost besede za izgradnjo zadnjega indeksa na 1024000 znakov. Med testiranjem smo opazili tudi, da se $LCP$ polje ne zgradi za besede dolžine 1024000 znakov, zato smo se odločil, da se ta test v tem koraku izpusti.

\begin{figure}[tb]
    \centering
    \includegraphics[width=\textwidth]{Slike/Zaslonski posnetek 2025-06-23 22-53-56.png}

    \caption{Posnetek zaslona upravljalnika opravil Htop med izgradnjo priponskega drevesa za besedilo dolžine 2048000 znakov.} 
    \label{fig:6GB}
\end{figure}



