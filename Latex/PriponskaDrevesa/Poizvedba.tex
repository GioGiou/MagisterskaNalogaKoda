Časovna učinkovito iskanja vzorcev v vhodni besedi $T$ je dosežena z izgradnjo priponskega drevesa. Zato bodo, v tem poglavju, predstavljene implementacije poizvedb za iskanje vzorcev nad besedo $T$ s pomočjo priponskega drevesa. Obstajajo tri poizvedbe, in sicer:
\begin{enumerate}
    \item \textit{prisotnost}$(T,P)$, ki preveri ali je vzorec $P$ prisoten v besedi $T$,
    \item \textit{številoPonovitev}$(T,P)$, ki vrne število ponovitev vzorca $P$ v besedi $T$, in
    \item \textit{seznamPojavov}$(T,P)$, ki vrne seznam indeksov v besedi $T$, kjer se pojavi vzorec $P$.
\end{enumerate}

Osnovna poizvedba nad besedo $T$ je \textit{prisotnost}$(T,P)$, saj ostali dve poizvedbi nadgradnji le te. Osnovna ideja iskanja vzorcev s priponskimi drevesi je obstaoj vzorca $P$ na začetku vsaj ene pripone besede $T$, natako tedaj ko je $P$ prisoten v $T$. Oziroma vzorec $P[1,m]$ je prisoten v besedi $T$, natako tedaj ko obstaja pripona $T[i,n]$, za katero velja $P=T[i,i+m]$ ($P$ je predpona pripone $T[i,n]$). 

Listi priponskga drevesa predstavljajo pripone besede $T$, zato je poizvedba \textit{prisotnost}$(T,P)$ s pomočjo priponskega drvesa implementirana s sprehodom iz \textit{korena} drevesa proti listom. Ker vsaka povezava predstavlja podniz besede $T[k,p]$, ki je lahko shranjen kot par indeksov $k$ in $p$, je potrebno preveriti, ali se $P$ ujema s $T[k,p]$. Če se vzorec ne ujema s podnizom, potem vzorec ni prisoten v besedi in zato poizvedba vrne \textit{false}, sicer se ujema s podnizom, torej je vzorec prisoten v besedi in zato poizvedba vrne \textit{true}. Tako predstavljen način iskanja deluje zgolj za vzorce, ki niso daljši od $p-k$ znakov. Če pa je vzorec $P$ daljši, se najprej pogleda prvih $p-k$ znakov in če se podniza ujemata se nadljuje s iskanjem na naslednji povezavi, ki se začne v vozlišču $v$, do katerega smo prišli po povezavi $T[k,p]$, na poti proti listom. Pri tem si je potrebno zapomniti koliko znakov smo že pregledali in to označimo z $o$. V vsakem koraku povečamo $o$ za $p-k$ ter perverimo, ali je $P[o+1,o+p-k]=T[k,p]$. Poizvedba se konča na povezavi, za katero velja, da je $p-k>=m-o$, če se je vseh $o$ dotakrat pregledani znakov ujemalo. V vozlišču $v$ je izbrana povezava, za katero velja, da se prvi znak povezave ujema z znakom $P[o+1]$. Izkanje te povezave potrebuje od $O(1)$ časa (vsako vozlišče ima polje velikosti $|\Sigma|$, tako da ima vsak znak alociran prostor za svojo povezavo, čeprav otrok neobstaja) do $O(|\Sigma|)$ časa (vsako vozlišče ima povezan seznam povezav do otrok), kar je še vedno konstanten čas, saj se abeceda $\Sigma$ ne spreminja skozi postopek izgradnje in poizvedb.

Operacija \textit{prisotnost}$(T,P)$ potrebuje $O(m)$ časa, da preveri prisotnost vzorca v besedilu. Operacija more preveriti ali se vsi znaki vzorca ujemajo z znaki na povezavah, ki so del poti od \textit{korena} proti listom, za kar potrebuje $O(m)$ časa. V vsakem notranjem vozlišču na poti pa potrebuje še dodatnega $O(1)$ časa, da se najde naslednjo povezavo. Ker je notranjih vozlišč na poti največ $m$, potem tudi celotna poizvedba potrebuje $O(m)$ časa.

Za primer iskanja vzamemo priponsko drevo iz Slike \ref{fig:PriponskoDrevo}, ki predstavlja besedo \enquote{KOKOŠ}, ter želimo preveriti prisotnost vzorca $P_1=\text{\enquote{KOŠ}}$, ki je prisoten v besedilu, ter vzorca $P_2=\text{\enquote{KOT}}$, ki pa ni prisoten v besedilu. Pri tem predpostavimo, da ima vsako vozlišče fiksno polje kazalcev na otroke (vsaka črka abecede ima eno celico v polju). Iskanje se začne v vozlišču \verb|koren|. Preveri se, ali velja \verb|koren.otroci['K']|$\ne$\textit{NIL}. Ker \verb|koren.otroci['K']| kaže na notranje vozlišče, ki ga imenujemo $v$, se lahko preveri, ali podniz na povezavi se ujema z $P_1$ oziroma $P_2$. Ker se oba vzorca začneta s \enquote{KO} in se ujema s podnizom na povezavi, si zapomnemo, da smo pregledali dve črki in nadaljujemo s pregledovanjem. Za vzorec $P_1$ preverimo v vozlišču $v$, ali velja $v$\verb|.otroci['Š']|$\ne$\textit{NIL}. Ker obstaja taka povezava lahko nadaljujemo z iskanjem, ampak smo že prevreverili vse črke vzorca, ker do vozlišča $v$ sta bila že pregledana $o=2$ znaka in za iskanje naslednje povezave se je pregledal tudi znak $P_1[3]=\text{Š}$. Zato lahko trdimo, da vzorec $P_1$ je prisoten v besedi \enquote{KOKOŠ}. Za razliko od vzorca $P_1$ se za vrorec $P_2$ v vozlišču $v$ preveri, ali velja $v$\verb|.otroci['T']|$\ne$\textit{NIL}. Ker ne obstaja povezava, ki predstavlja podniz z prvim znakom 'T', potem takem tudi vzorec $P_2$ ni prisoten v besedi \enquote{KOKOŠ}.

Preostali poizvedbi sta si zelo podbni in imata isto osnovno idejo implementacije. Brez škode za splošnost lahko uporabimo poizvedbo \textit{številoPonovitev}$(T,P)$ za razložiti idejo. Vzorec se nahaja na začetku sprehoda od \textit{korena} proti listom, zato je število ponovtiev vzorca v besedi enako šetvilu listov v drevesu, katerih pot do njih se začne z vzorcem $P$. Isto velja tudi za poizvedbo \textit{seznamPojavov}$(T,P)$, pri čemer pa indeksi pripon, ki so shranjeni v listih, predstavljajo indekse v besedi, kjer se pojavi vzorec $P$.

Začetka implementacije obeh poizvedb sta enaki kot pri poizvedba \textit{prisotnost}$(T,P)$. Če je vzorec $P$ prisoten v besedilu, potem se vzorec $P$ konča na povezavi, ki vodi v vozlišče $v$. Zato velja, da so vsi listi priponskega drevesa, ki predstavljajo pripone s predpono $P$, tudi listi v poddrevesu s korenom v vozlišču $v$. Torej za najti oziroma prešteti vse ponovitve vzorca $P$ v vhodni besedi $T$, se je potreno sprehoditi po poddrevesu. Poizvedba \textit{številoPonovitev}$(T,P)$ vrne število obiskanih listov v poddrevesu s korenov v $v$, če pa vzorec $P$ ni prioten v besedi pa vrne $0$. Poizvedba \textit{seznamPojavov}$(T,P)$ pa vrne seznam vseh indeksov pripon, ki so predstavljeni z obiskanimi listi v sprehodu, če pa vzorec $P$ ni prisoten v besedi pa vrne prazen seznam $[~]$.

Časovna zahtevnost obeh poizvedb je $O(m+\textit{occ})$, pri čemer je \textit{occ} število pojavov vzorca v besedi $T$. Ker je prvo potrebno preveriti, ali je vzorec prisoten v drevesu, je potreno izvesti iste korake kot za poizvedbo \textit{prisotnost}$(T,P)$, zakar je potrebno $O(m)$ časa. Za najti vse liste v poddrevesu pa je potrebno še $O(\textit{occ})$ čas. Ker v priponskem drevesu z $n$-timi listi je $O(n)$ vozlišč, potem je v poddrevesu priposnkega drevesa z \textit{occ} listi $O(\textit{occ})$ vozlišč. Ker tako pregled v globino kot tudi pregled v širino potrebujeta v drevesih z $n$-timi vozlišči $O(n)$ časa, potem takem za najti vse liste poddrevesa potrebujemo $O(\textit{occ})$ časa.

Za primer vzamemo besedo $T=\text{\enquote{KOKOŠ}}$, za katero imamo izgrajeno priponsko drevo, ki je prikazano na Sliki \ref{fig:PriponskoDrevo}. V besedi zelimo preveriti, koliko krat se pojavi vzorec $P=\text{\enquote{KO}}$ oziroma želimo narediti poizvedbo \textit{številoPonovitev}$(T,P)$. Poizvedbo začnemo v \textit{korenu} priponskega drevesa, kjer preverimo ali obstaja povezava na vozliše, ki se začne z znakom $P[1]=\textit{'K'}$. Ker obstaja povezava \verb|koren.otroci['K']|, imenujemo to vozlišče $v$ in preverimo, ali se preostanek znakov na povezavi ujema z vzorcem. Povezava predstavlja podniz $T[1,2]=$\enquote{KO} in ker smo že preverili prvi znak, je potrebni preverit še drugi znak, ki pa se tudi ujema.Vzorec dolg dva znaka, zato se preverjanje prisotnosti vzorca ustavi ter nadaljujemo s preštevanjem listov v poddrevesu s korenov v $v$. Brez škode za splošnost lahko uporabino pregled v globino ter začnemo s pregledom pregledovati v levem poddrevesu. Skrajno levi otrok od $v$ je list, ki predstavlja predpono z indeksom 1, zato povečamo število obiskanih listov iz 0 na 1. Nato pregledamo še drugega (zadnjega) otroka, ki je tudi list in predstavlja predpono z indeksom 3, zato se poveča število obiskanih listov iz 1 na 2. Ker smo pregledali celotno poddrevo, poizvedba vrne število 2, kar pomeni da se vzorec $P=\text{\enquote{KO}}$ pojavi v besedi $T$ dvakrat. Ča pa bi želeli poiskati indekse v besedi, kjer se vzorec pojavi, oziroma izvesti poizvedbo \textit{seznamPojavov}$(T,P)$, pa bi bil postopek enak. Pri tem pa bi beležili indekse pripon, namesto štetja obiskanih listov. Ob obisku prvega lista bi se na konec praznega seznama vstavil indeks 1, za drugi listu pa bi se na konec seznama vstavil še indeks 3. Torej bi poizvedba vrnila seznam $[1,3]$.