Časovno učinkovito iskanje vzorcev v vhodni besedi $T$ je doseženo z izgradnjo priponskega drevesa. Zato bodo v tem podpoglavju predstavljene implementacije poizvedb za iskanje vzorcev nad besedo $T$ z uporabo priponskega drevesa. Obstajajo tri poizvedbe, in sicer:
\begin{enumerate}
    \item \textit{prisotnost}$(T,P)$, ki preveri, ali je vzorec $P$ prisoten v besedi $T$,
    \item \textit{številoPonovitev}$(T,P)$, ki vrne število ponovitev vzorca $P$ v besedi $T$, in
    \item \textit{seznamPojavov}$(T,P)$, ki vrne seznam indeksov v besedi $T$, kjer se pojavi vzorec $P$.
\end{enumerate}

Osnovna poizvedba nad besedo $T$ je \textit{prisotnost}$(T,P)$, saj sta ostali dve poizvedbi nadgradnji le te. Osnovna ideja iskanja vzorcev s priponskimi drevesi je obstoj vzorca $P$ na začetku vsaj ene pripone besede $T$ natako tedaj, ko je $P$ prisoten v $T$. Oziroma vzorec $P[1,m]$ je prisoten v besedi $T$ natako tedaj, ko obstaja pripona $T[i,n]$, za katero velja $P=T[i,i+m]$ ($P$ je predpona pripone $T[i,n]$). 

Listi priponskega drevesa predstavljajo pripone besede $T$, zato je poizvedba \textit{prisotnost}$(T,P)$ z uporabo priponskega drevesa implementirana s sprehodom iz \textit{korena} drevesa proti listom. Ker vsaka povezava predstavlja podniz besede $T[k,p]$, ki je lahko shranjen kot par indeksov $k$ in $p$, je potrebno preveriti, ali se $P$ ujema s $T[k,p]$. Če se vzorec ne ujema s podnizom, potem vzorec ni prisoten v besedi in zato poizvedba vrne \textit{false}. Ko pa se $P$ ujema s podnizom, potem je vzorec prisoten v besedi in zato poizvedba vrne \textit{true}. Tako predstavljen način iskanja deluje zgolj za vzorce, ki niso daljši od $p-k$ znakov. Če pa je vzorec $P$ daljši, se najprej pogleda prvih $p-k$ znakov. Če se podniza ujemata, se nadaljuje z iskanjem na naslednji povezavi, ki se začne v vozlišču $v$, do katerega smo prišli po povezavi $T[k,p]$ na poti proti listom. Pri tem si je potrebno zapomniti, koliko znakov smo že pregledali, in to označimo z $o$. V vsakem koraku povečamo $o$ za $p-k$ ter perverimo, ali je $P[o+1,o+p-k]=T[k,p]$. Poizvedba se konča na povezavi, za katero velja, da je $p-k\ge m-o$, če se je vseh $o$ do takrat pregledanih znakov ujemalo. V vozlišču $v$ je izbrana povezava, za katero velja, da se prvi znak povezave ujema z znakom $P[o+1]$. Iskanje te povezave vzame od $O(1)$ časa (vsako vozlišče ima polje velikosti $|\Sigma|$, tako da ima vsak znak alociran prostor za svojo povezavo, čeprav otrok ne obstaja) do $O(|\Sigma|)$ časa (vsako vozlišče ima povezan seznam povezav do otrok), kar je še vedno konstanten čas, saj se abeceda $\Sigma$ ne spreminja skozi postopek izgradnje in poizvedb.

Operacija \textit{prisotnost}$(T,P)$ potrebuje $O(m)$ časa, da preveri prisotnost vzorca v besedilu. Operacija mora preveriti, ali se vsi znaki vzorca ujemajo z znaki na povezavah, ki so del poti od \textit{korena} proti listom, za kar potrebuje $O(m)$ časa. V vsakem notranjem vozlišču na poti pa potrebuje še dodatno $O(1)$ časa, da najde naslednjo povezavo. Ker je notranjih vozlišč na poti največ $m$, potem tudi celotna poizvedba potrebuje $O(m)$ časa.

Za primer iskanja vzememo priponsko drevo na Sliki \ref{fig:PriponskoDrevo}, ki predstavlja besedo $T=$\enquote{KOKOŠ}. V besedi želimo preveriti prisotnost vzorca $P_1=\text{\enquote{KOŠ}}$, ki je prisoten v besedilu, ter vzorca $P_2=\text{\enquote{KOT}}$, ki pa ni prisoten v besedilu. Pri tem predpostavimo, da ima vsako vozlišče fiksno polje kazalcev na otroke (vsaka črka abecede ima eno celico v polju). Iskanje se začne v vozlišču \verb|koren|. Preveri se, ali velja \verb|koren.otroci['K']|$\ne$\textit{NIL}. Ker \verb|koren.otroci['K']| kaže na notranje vozlišče, ki ga imenujemo $v$, se lahko preveri, ali podniz na povezavi se ujema s $P_1$ oziroma $P_2$. Ker se oba vzorca začneta s \enquote{KO} in se ujema s podnizom na povezavi, si zapomnemo, da smo pregledali dve črki, in nadaljujemo s pregledovanjem. Za vzorec $P_1$ preverimo v vozlišču $v$, ali velja $v$\verb|.otroci['Š']|$\ne$\textit{NIL}. Ker obstaja taka povezava, lahko nadaljujemo z iskanjem, ampak smo že preverili vse črke vzorca, ker do vozlišča $v$ sta bila že pregledana $o=2$ znaka in za iskanje naslednje povezave se je pregledal tudi znak $P_1[3]=\text{Š}$. Zato lahko trdimo, da vzorec $P_1$ je prisoten v besedi \enquote{KOKOŠ}. Za razliko od vzorca $P_1$ se za vrorec $P_2$ v vozlišču $v$ preveri, ali velja $v$\verb|.otroci['T']|$\ne$\textit{NIL}. Ker ne obstaja povezava, ki predstavlja podniz z prvim znakom 'T', torej tudi vzorec $P_2$ ni prisoten v besedi \enquote{KOKOŠ}.

Preostali poizvedbi sta si zelo podobni in imata isto osnovno idejo implementacije. Brez škode za splošnost lahko uporabimo poizvedbo \textit{številoPonovitev}$(T,P)$, da razložimo idejo. Vzorec se nahaja na začetku sprehoda od \textit{korena} proti listom, zato je število ponovtiev vzorca v besedi enako številu listov v drevesu, katerih pot do njih se začne z vzorcem $P$. Isto velja tudi za poizvedbo \textit{seznamPojavov}$(T,P)$, pri čemer pa indeksi pripon, ki so shranjeni v listih, predstavljajo indekse v besedi, kjer se pojavi vzorec $P$.

Začetka implementacije obeh poizvedb sta enaki kot pri poizvedba \textit{prisotnost}$(T,P)$. Če je vzorec $P$ prisoten v besedilu, potem se vzorec $P$ konča na povezavi, ki vodi v vozlišče $v$. Zato velja, da so vsi listi priponskega drevesa, ki predstavljajo pripone s predpono $P$, tudi listi v poddrevesu s korenom v vozlišču $v$. Torej za najti oziroma prešteti vse ponovitve vzorca $P$ v vhodni besedi $T$ se je potrebno sprehoditi po poddrevesu. Poizvedba \textit{številoPonovitev}$(T,P)$ vrne število obiskanih listov v poddrevesu s korenom v $v$, če pa vzorec $P$ ni prioten v besedi, pa vrne $0$. Poizvedba \textit{seznamPojavov}$(T,P)$ pa vrne seznam vseh indeksov pripon, ki so predstavljeni z obiskanimi listi v sprehodu, če pa vzorec $P$ ni prisoten v besedi, pa vrne prazen seznam $[~]$.

Časovna zahtevnost obeh poizvedb je $O(m+\textit{occ})$, pri čemer je \textit{occ} število pojavov vzorca v besedi $T$. Ker je prvo potrebno preveriti, ali je vzorec prisoten v drevesu, je potrebno izvesti iste korake kot za poizvedbo \textit{prisotnost}$(T,P)$, za kar je potrebno $O(m)$ časa. Za najti vse liste v poddrevesu pa je potrebno še $O(\textit{occ})$ časa. Ker je v priponskem drevesu z $n$-timi listi $O(n)$ notranjh vozlišč, potem je v poddrevesu priponskega drevesa z \textit{occ} listi $O(\textit{occ})$ vozlišč. Ker tako pregled v globino kot tudi pregled v širino potrebujeta v drevesih z $n$-timi vozlišči $O(n)$ časa, potemtakem za najti vse liste poddrevesa potrebujemo $O(\textit{occ})$ časa.

Za primer vzemimo besedo $T=\text{\enquote{KOKOŠ}}$, za katero imamo zgrajeno priponsko drevo, ki je prikazano na Sliki \ref{fig:PriponskoDrevo}. V besedi želimo preveriti, kolikokrat se pojavi vzorec $P=\text{\enquote{KO}}$ oziroma želimo narediti poizvedbo \textit{številoPonovitev}$(T,P)$. Poizvedbo začnemo v \textit{korenu} priponskega drevesa, kjer preverimo, ali obstaja povezava na vozliše, ki se začne z znakom $P[1]=\textit{'K'}$. Ker obstaja povezava \verb|koren.otroci['K']|, imenujemo to vozlišče $v$ in preverimo, ali se preostanek znakov na povezavi ujema z vzorcem. Povezava predstavlja podniz $T[1,2]=$\enquote{KO}, in ker smo že preverili prvi znak, je potrebno preverit še drugi znak, ki pa se tudi ujema. Vzorec je dolg dva znaka, zato se preverjanje prisotnosti vzorca ustavi ter nadaljujemo s preštevanjem listov v poddrevesu s korenom v $v$. Brez škode za splošnost lahko uporabimo pregled v globino ter začnemo s pregledom pregledovati v levem poddrevesu. Skrajno levi otrok od $v$ je list, ki predstavlja predpono z indeksom 1, zato povečamo število obiskanih listov iz 0 na 1. Nato pregledamo še drugega (zadnjega) otroka, ki je tudi list in predstavlja predpono z indeksom 3, zato se poveča število obiskanih listov iz 1 na 2. Ker smo pregledali celotno poddrevo, poizvedba vrne število 2, kar pomeni, da se vzorec $P=\text{\enquote{KO}}$ pojavi v besedi $T$ dvakrat. Ča pa bi želeli poiskati indekse v besedi, kjer se vzorec pojavi, oziroma izvesti poizvedbo \textit{seznamPojavov}$(T,P)$, bi bil postopek enak. Pri tem bi beležili indekse pripon namesto štetja obiskanih listov. Ob obisku prvega lista bi se na konec praznega seznama vstavil indeks 1, za drugi list pa bi se na konec seznama vstavil še indeks 3. Torej bi poizvedba vrnila seznam $[1,3]$.