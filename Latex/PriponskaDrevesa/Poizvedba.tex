Razlog za izgradno priponskega drevesa je časovno učinkovito iskanje vzorcev v vhodni besedi $T$. Zato bo v tem poglavju predstavljene implementacije poizvedb za iskanje vzorcev nad besedo $T$ s pomočjo priponskega drevesa. Pri tem se pozna tri poizvedbe, in sicer:
\begin{enumerate}
    \item \textit{prisotnost}$(T,P)$, ki preveri ali je vzorec $P$ prisoten v besedi $T$,
    \item \textit{številoPonovitev}$(T,P)$, ki vrne število ponovitev vzorca $P$ v besedi $T$, in
    \item \textit{seznamPojavov}$(T,P)$, ki vrne seznam indeksov besede $T$, kjer se pojavi vzorec $P$.
\end{enumerate}

Osnovna poizvedba nad besedo $T$ je \textit{prisotnost}$(T,P)$, saj ostali dve poizvedbi vrnejo bolj natančne odgovore o vzorc $P$. Osnovna ideja iskanja vzorcev s priponskimi drevesi je prisotnost vzorca $P$ na začetku vsaj ene pripone besede $T$, če je $P$ prisoten v $T$. Ali z drugimi besedami vzorec $P[1,m]$ je prisoten v besedi $T$, natako tedaj ko obstaja taka pripona $T[i,n]$, za katero velaj $P=T[i,i+m]$ ($P$ je predpona pripone $T[i,n]$). 

Ker listi priponskga drevesa predstavljajo pripone besede $T$, je poizvedba \textit{prisotnost}$(T,P)$ s priponskim drvesom implementirana s sprehodom iz \textit{korena} drevesa proti listom. Ker vsaka povezava predstavlja podniz besede $T[k,p]$, ki je lahko shranjen kot par indeksov $k$ in $p$, je potrebno preveriti ali $P$ ujema z $T[k,p]$. Če se vzorec ne ujema z podnizom, potem vzorec ni prisoten v besedi in zoto se vrne \textit{false}, sicer pa se ujema z podnizom, torej je vzorec prisotten v besedi in zato se vrne \textit{true}. Tako predstavljen način iskanja deluje zgolj za vzorce, ki niso daljši od $p-k$ znakov. Če pa je vzorec $P$ daljši, se prvo pogleda prvih $p-k$ znakov in če se podniza ujemata se nadljuje s iskanjem na naslednji povezaviv, ki se začne v vozlišču $v$ do katerega smo prišli po povezavi $T[k,p]$, na poti proti listom. Pri tem si je potrebno zapomniti, koliko znakov smo že pregledali, in to označimo z $o$. V vsakem koraku povečamo $o$ za $p-k$ ter se perveri, da je $P[o+1,o+p-k]=T[k,p]$. Pozvedba se konča na povezavi, za katero velaj, da je $p-k>=m-o$, če se je vseh $o$ dotakrat pregledaniz znakov ujemalo. V vozlišču $v$ je izbrana povezava, za katero velja, da se prvi znak povezave ujema z znakom $P[o+1]$. Izkanje te povezave potrebuje od $O(1)$ časa (vsako vozlišče ima polje velikosti $|\Sigma|$, tako da ima vsak znak alociran prostor za svojo povezavo, čeprav otrok neobstaja) do $O(|\Sigma|)$ časa (vsako vozlišče ima povezan seznam povezav do otrok), kar je še vedno potrebuje konstanten čas, saj se abeceda $\Sigma$ ne spreminja skozi postopek izgradnje in poizvedb.

Operacija \textit{prisotnost}$(T,P)$ potrebuje $O(m)$ časa, da preveri prisotnost vzorca v besedilu. Operacija more preveriti ali se vsi znaki vzorca ujemajo z znaki na povezavah, ki so del poti od \textit{korena} proti listom, za kar potrebuje $O(m)$ časa. V vsakem notranjem vozlišču na poti pa potrebuje še dodatnega $O(1)$ časa, da najde naslednjo povezavo. Ker je notranjih vozlišč na poti največ $m$, potem tudi celotna poizvedba potrebuje $O(m)$ časa.

Za primer iskanja vzamemo priponsko drevo iz Slike \ref{fig:PriponskoDrevo}, ki predstavlja besedo \enquote{KOKOŠ}, ter želimo preveriti prisotnost vzorca $P_1=\text{\enquote{KOŠ}}$, ki je prisoten v besedilu, ter vzorca $P_2=\text{\enquote{KOT}}$, ki pa ni prisoten v besedilu. Pri tem predpostavimo, da ima vsako vozlišče fiksno polje kazalcev na otroke (za vsako črko abecede ima eno celico). Iskanje se začne v vozlišču \verb|koren|. Preveri se, če velja \verb|koren.otroci['K']|$\ne$\textit{NIL}. Ker \verb|koren.otroci['K']| kaže na notranje vozlišče, ki ga imenujemo $v$, se lahko preveri če podniz na povezavi se ujema z $P_1$ oziroma $P_2$. Ker se oba vzorca začneta z \enquote{KO} in se vjema z podnizom na povezavi, si zapomnemo, da smo pregledal dve črki in nadaljujemo z pregledovanjem. Za vzorec $P_1$ preverimo v vozlišču $v$, če velja $v$\verb|.otroci['Š']|$\ne$\textit{NIL}. Ker obstaja taka povezava lahko nadaljujemo s iskanjem, ampak smo prevreverili vse črke vzorca, ker do vozlišča $v$ sta bila že pregledana $o=2$ znaka in iskanje nove povezave je preverilo, da znak $P_1[3]=Š$ sledi že pregledanem podnizu. Zato lahko trdimo, da vzorec $P_1$ je prisoten v besedi \enquote{KOKOŠ}. Za razliko od vzorca $P_1$ se za vrorec $P_2$ v vozlišču $v$ preveri, če velja $v$\verb|.otroci['T']|$\ne$\textit{NIL}. Ker ne obstaja povezava, ki predstavlja podniz z prvim znakom 'T', potem takem tudi vzorec $P_2$ ni prisoten v besedi \enquote{KOKOŠ}.

Preostali poizvedbi stat si zelo podbni in imata isto osnovno idejo implementacije. Brez škode za splošnost lahko vzamemo poizvedbo \textit{številoPonovitev}$(T,P)$ za razložiti idejo. Vzorec se nahaja na začetku sprehoda od \textit{korena} proti listom, zato je število ponovtiev vzorca v besedi enako šetvilu listov v drevesi, katerih pot do njih se začne z vzorcem $P$. Podobno isto velja tudi za poizvedbo \textit{seznamPojavov}$(T,P)$, pri čemer pa indeksi pripon, ki so shranjeni v listih, predstavljajo indekse v besedi, kjer se pojavi vzorec $P$.

Začetka implementacije obeh poizvedb sta enaki kot pri poizvedba \textit{prisotnost}$(T,P)$. Če je vzorec $P$ prisoten v besedilu, potem se vzorec $P$ konča na povezavi, ki vodi v vozlišče $v$. Zato velja, da so vsi listi priponskega drevesa, ki predstavljajo pripone z predpono $P$, tudi listi v poddrevesu z korenom v vozlišču $v$. Torej za najti oziroma prešteti vse ponovitve vzorca $P$ v vhodni besedi $T$, se je potreno sprehoditi po poddrevesu. Poizvedba \textit{številoPonovitev}$(T,P)$ vrne število obiskanih listov v pod drevesu z korenov v $v$, če pa vzorec $P$ ni prioten v besedi pa vrne $0$. Poizvedba \textit{seznamPojavov}$(T,P)$ pa vrne seznam vseh indeksov priponpon, ki so predstavljeni z obiskanimi listi v sprehodu, če pa vzorec $P$ ni prioten v besedi pa vrne prazen seznam $[]$.

Časovna zahtevnost obeh poizvedbi $O(m+\textit{occ})$, pri čemer \textit{occ} je število pojavov vzorca v besedi $T$. Ker je prvo potrebno preveriti, ali je vzorec prisoten v drevesu, je potreno izvesti iste korake kot za poizvedbo \textit{prisotnost}$(T,P)$, zakar je potrebno $O(m)$ časa. Za najti vse liste v poddrevesu pa je potrebno $O(\textit{occ})$ čas. Ker v priponskem drevesu z $n$-timi listi je $O(n)$ vozlišč, potem je v poddrevesu priposnkega drevesa z \textit{occ} listi $O(\textit{occ})$ vozlišč. Ker tako pregled v globino kot tudi pregled v širino potrebujeta v drevesih z $n4-tim$ vozlišči $O(n)$ časa, potem takem za najti vse liste poddrevesa potrebujemo $O(\textit{occ})$ časa.

Če ponovno za primer vzamemo besedo $T=\text{\enquote{KOKOŠ\$}}$ za katero imamo izgrajeno priponsko drevo, ki je prikazano na Sliki \ref{fig:PriponskoDrevo}. V besedi zelimo preveriti, koliko krat se pojavi vzorec $P=\text{\enquote{KO}}$ oziroma zelimo narediti poizvedbo \textit{številoPonovitev}$(T,P)$. Poizvedbo začnemo v \textit{korenu} priponskega drevesa, kjer preverimo ali obstaja povezava na vozliše za znak $P[1]=\textit{'K'}$. Ker je \verb|koren.otroci['K']| taka povezava obstaja, imenujemo to vozlišče $v$ in preverimo, ali se preostanek znakov na povezavi ujema z vzorcem. Povezava predstavlja podniz $T[1,2]=$\enquote{KO} in ker smo že preverili prvi znak, je potrebni preverit še drugi znak, ki pa se tudi ujema. Ker je vzorec dolg dva znaka, se preverjanje prisotnosti vzorca ustavi ter madaljujemo z preštevanjem litov, ki so v poddrevesu z korenov v $v$. Brez škode za splošnost lahko rečemo, da uporabino pregled v globino ter začnemo pregledovati iz levega poddrevesa proti desnemu poddrevesu. Skrajno levi otrok od je list, ki predstavlja predpono z indeksom 1, zato povečamo število obiskanih listov iz 0 na 1. Nato pregledamo še drugega in zadnjega otroka, ki je tudi list in predstavlja predpono z indeksom 3, zato se poveča število obiskanih listov iz 1 na 2. Ker smo pregledali celotno poddrevo, poizvedba vrne število 2, kar pomeni da se vzorec $P=\text{\enquote{KO}}$ pojavi v besedilu $T$ dvakrat. Ča pa bi želeli izvedeti namesto števila ponovitev vzorca, indekse v besedi, kjer se vzorec pojavi, oziroma izvesti poizvedbo \textit{seznamPojavov}$(T,P)$, pa postopek bil enak. Pri tem pa bi beležili indekse pripon, namesto štetja obiskanih listov. Ko obiščemo prvi list bi v prazen seznam vstavili na konec seznama indeks 1, v drugem listu pa bi v seznam na konec vstavili še indeks 3. Torej bi poizvedba vrnila seznam $[1,3]$.