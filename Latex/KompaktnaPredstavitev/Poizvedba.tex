V kompaktnem priponskem drevesu se prisotnost vzorca išče s pomočjo vzvratnega iskanja (angl. \textit{Backward Search}) vzorca v priponskem polju $SA$. Vzvratno iskanje za predhodno predstavljeno kompaktno priponsko polje, ki je prikazano s Algoritmom \ref{alg:prisotnostCST}, potrebuje $O(mt_\Psi)$ časa, da se izvrši. Za drugačno implementacijo kompaktnega priponskega polja, se nadomesti vrstico 6 v Algoritmu \ref{alg:prisotnostCST} z binarnim iskanjem nad $\Psi_c$ in zato je potrebno $O(m\log{n}t_\Psi)$ časa. Nato pa je potrebo preveriti, ali je $[s,e]\ne[-1,-1]$, za kar je potrebno konstantno časa. Torej je potrebno $O(mt_\Psi)$ časa za preveriti prisotnost vzorca ali $O(m\log{n}t_\Psi)$ z uporabo binarnega iskanja. V primeru, da se uporabi opisano kompaktno priponsko polje, pa se poizvedba izvrši v času $O(m)$.

Naslednja poizvedba je \textit{š}$teviloPonovitev(vzorec)$, ki vrne  število pojavov vzorca v besedilu, kar je ekvivalentno številu pripon v priponskem drevesu, ki se začnejo z vzorcem $vzorec$. V priponskem drevesu je potrebno najti vozlišče $v$, za katerega velja $besedilo(v)[1,m]=vzorec$. Po tem takem je število ponovitev vzorca enako številu listov v poddrevesu s korenom v vozlišču $v$. Štetje vseh listov zahteva $O(n)$ časa, za iskanje vozlišča $v$ pa je potrebno $O(m)$ časa, saj iskanje poteka na isti način, kot v poizvedbi  $prisotnost(vzorec)$. V kompaktnem priponskem drevesu, pa je operacija ponovno implementirana s pomočjo vzvratnega iskanja. Operacija \textit{š}$teviloPonovitev(vzorec)$ je implementiran kot razlika $e-s$, kjer $s$ predstavlja prvo pripono, ki se začne z vzorcem $vzorec$, in $e$ je zadnja tako pripona, torej je razlika $s-e$ število pripon, ki se začnejo z vzorcem $vzorec$. Torej operacija ponovno potrebuje $O(mt_\Psi)$ oziroma $O(mt_\Psi\log{n})$ časa, da se izvrši.

Zadnja predstavljena poizvedba pa je $seznamPojavov(vzorec)$, ki vrne vsa začetna mesta pojavov vzorca $vzorec$  v besedilu $T$. To je ekvivalentno seznamu vseh pripon besedila $T$, ki se začnejo z vzorcem $vzorec$. V priponskem drevesu je to implementirano na podoben način, kot poizvedba \textit{š}$teviloPonovitev(vzorec)$, pri čemer namesto štetja listov v poddrevesu s korenom v vozlišču $v$, se v seznam pripon dodaja vse pripone, ki so predstavljene kot listi v poddrevesu s korenom v vozlišču $v$. V kompaktnem priponskem drevesu pa je poizvedba ponovno implementirana s pomočjo vzvratnega iskanja. Z vzvratnim iskanjem se naračuna interval v priponskem polju $SA[s,e]$. Za pridobitev položajev ponovitev vzorca v besedilu, je potrebno ustvariti seznam $[SA[s],SA[s+1],\dots,SA[e]]$, kar zahteva še dodatnih $e-s$ korakov, pri čemer vsak korak potrebuje $O(t_{SA})$ časa za se izvršit. Torej poizvedba $seznamPojavov(vzorec)$ potrebuje $O(mt_\Psi+t_{SA})$ oziroma $O(mt_\Psi \log{n}+t_{SA})$ časa. Z predhodno predstavljeno implementacijo kompaktnega priponskega drevesa pa je potrebno $O(m+\log{n})$ časa.

Iz implementacij poizvedb nad kompaktnim priponskim drevesom se lahko vidi, da so vse tri poizvedbe implementirane zgolj s pomočjo kompaktnega priponskega polja. Iz tega se lahko sklepa, da sta topologija drevesa $\tau$ in $LCP$ polje odvečni podatkovni strukturi. To je res zgolj za osnovne poizvedbe nad besedilom $T$, ki so lahko izvršene zgolj s priponskim polje v enakem času. Poizvedbe, kot so najdaljši ponavljajoči podniz, najdaljši palindrom, ki je implementirana s pomočjo priponskega drevesa konkatenacije obrata $T_z'$ besedila $T_z$, $T=T_{z}\#T_{z}'\$$, in najdaljši skupni niz besedila $T_1$ in $T_2$, ki je implementirana s pomočjo priponskega drevesa konkatenacje obeh besedil $T=T_1 \# T_2\$ $. Na primer poizvedbe najdaljši ponavljajoči podniz je podniz $T[SA[i],SA[i]+globinaNiza(v)]$, pri čemer $i$ je skrajno levi list poddrevesa s korenom v notranjem vozlišču $v$ in velja, da je $LCP[i]$ največji element v $LCP$ polju, torej zahteva $O(nt_{SA})$ časa. Operacije $globinaNiza(v)$ ni potrebno naračunati, saj je enaka $LCP[i]$, torej se še vedno izvede $O(nt_{SA})$ časa, pri tem pa ni uporabljena topologija drevesa. V primeru, da želimo najti drugi najdaljši ponavljajoč se podniz $T[SA[j],SA[j]+globinaNiza(u)]$, pri čemer je $j$ skrajno levi list poddrevesa s korenom v notranjem vozlišču $u=sl(v)$. Za izračunat le tega pa je potrebo $O(nt_{SA}+t_\Psi)$ časa ter se uporabi vse tri podatkovne strukture kompaktnega priponskega drevesa \cite{Valimaki2007, Weiner1973, Navarro2016}.