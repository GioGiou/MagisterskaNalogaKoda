Bitno polje (angl. \textit{bit vector}) $B$ dolžine $b=|B|$ je polje, v katerem je shranjenih $b$ bitov. Ker je dostop do posameznega bita možen v konstantnem času, se bitno polje lahko uporabi kot osnovna podatkovna struktura za implementacijo kompaktnih predstavitve drugih podatkovnih struktur. Primer take podatkovne strukture, ki uporabja bitno polje za svojo kompaktno predstavitev, je drevo.

V nadajevanju tega podpoglavja bo predstavljeno, kako učinkovito shraniti bitno polje ter ohraniti dostop do podatkov v konstantem času. Predstavljene bodo še druge operacije nad bitnimi polji, ki se uporabljajo za reševanje problemov, ki so predstavljeni z bitnimi polji. Predstavljene operacije so: $rang(B,i)$ (angl. \textit{rank}), $izbira(B,i)$ (angl. \textit{select}), $predhodnik(B,y)$, $naslednik(B,y)$ in dodatne operacije nad intervali (angl. \textit{range querry}) bitnega polja. Vse predstavljene operacije želimo opraviti čim bolj učinkovito ter pri tem uporabiti čim manj dodatnega prostora.

%
    %Najbolj osnovna podatkovna struktura, ki bo tudi osnova za vse ostale kompaktne predstavitve podatkovnih struktur, je bitno polje (angl. \textit{bit vector}). Kot samo ime podatkovne strukture pove, bitno polje $B$ dolžine $n$ je polje, v katerem je shranjeni $n$ bitov, do katerih želimo dostopati v konstantnem času. Poleg dostopa do bitov, bitno polje podpira še dve osnovni operaciji: $rang_v(B,i)$ (angl. \textit{rank}) in $izbira_v(B,i)$ (angl. \textit{select}).
    %
    %je kompaktna podatkovna struktura, ki je osnova za ostale kompaktne podatkovne strukture. Bitna polja so osnova za kompaktno predstavitev topologijo drevesa. Univerzalna množica vseh bitnih polj dolžine $n$ je velikosti $\left |N\right |=2^n$, torej bitno polje ima prostorsko zahtevnost $n+o(n)$ bitov. Pri tem je potrebnih $n$ bitov za shraniti celotno bitno polje ter dodatnih $o(n)$ bitov za implementacijo operacij nad njim. Bitno polje $B$ podpira tri operacije:  ter $dostop(B,i)$ (angl. \textit{access}), ki vrne $i$-ti bit bitnega polja $B$.

\paragraph{Model računaja, shramba in dostop:}
Preden se lahko predstavi način shranjevanja bitnega polja, je potrebno predstaviti uporabljen model računanja. Splošen model računanja bo uporabljen, saj se različne arhitekture mikro procesorjev razlikujejo med seboj in bi bilo potreno narediti analizo za vsako arhitekuro posebaj. Zato bo izbran model računanja Računalnik z naključnim dostopom (angl. \textit{random-access machine} oziroma RAM). Bolj natančno bo uporabljen besedni RAM  (angl. \textit{word RAM}).

Osnovna različica RAM modela podpira, da so vse aritmetične operacije nad celimi števili in logične operacijami nad biti izvedene v konstantnem času. Poleg tega RAM omogoča dostopa do spomina v konstantnem času ter linearni čas za dodelitev zaporednega spomina. Vse te operacije so storjene v enakem času tudi v besednem RAM modelu. Edina razlika med modeloma je, da RAM predpostavlja neskončni spomin za razliko od besednega RAM, ki pa omeji velikost spomina na $U$ naslovov in posledično je velikost ene besede na $w=\log_2 U$\footnote{v nadaljevanju bo $\log_2 n$ zapisan kot $\log n$} bitov, kar je velikost enega naslova \cite{Fredman1990,Morin2013,Navarro2016}. Pri tem se lahko definira tudi \enquote{cela števila} (angl. \textit{Integer}). \enquote{Cela števila} so definirana kot podmnožica celih števil, ki so lahko predstavljena v dvojiškem zapisu z $w$ biti \cite{Navarro2016}.

Intuitivni način shranjevanja bitnega polja $B$ dolžine $b$ v spominu bi bil tak, da bi se vsaka celica polja shranila v spominu na lastnem naslovu. Na ta način bo operacija $dostop(B,i)=B[i]$ potrebovala konstanten čas, da se izvede. Pri tem pa bo bitno polje potrebovalo $O(b)$ bitov oziroma $wb$ bitov. Na ta način imam vsaka celica bitnega polja $w-1$ odvečnih bitov. 

Zato se pojavi vprašanje, ali je mogoče izogniti teh $b(w-1)$ odvečnih bitov. Če je mogoče izogniti uporabi teh odvečnih bitov, bi bitno polje $B$ potrebovalo zgolj $b+o(b)$ bitov (dodatnih $o(b)$ bitov je potrebnih, če $b$ ni večkratnik velikosti \enquote{celega števila} $w$). Torej bi se lahko bitno polje $B$ predstavilo kot polje \enquote{celih števil} $W\left[1,\left\lceil\frac{b}{w}\right\rceil\right]$. Naslednji problem, ki ga je potrebno rešiti, je, kako učinkovito dostopati do $i$-tega bita v bitnem polju. V konstantnem času lahko dostopamo do celice v polju $W$, v kateri je shranjen $i$-ti bit. Le ta je shranjen v celici $W\left[\left\lceil\frac{i}{w}\right\rceil\right]=w_i$. Naivna metoda dostopa do bita v \enquote{celem številu} bi bila z bitnim premikom (angl. \textit{bit shift}) v desno, ponovljenim $(w-r)$-krat, pri čemer je $r=((i-1)\mod{w}) +1$. Za to je potrebno $O(w)$ časa. Ker pa je en premik v desno enakovren celoštevilskemu deljenju števila z dva, se lahko nadomesti premike v desno s celoštevilskemu deljenjem števila $w_i$ s številom $2^{w-r}$. Torej dostop do $i$-tega bita v bitem polju $B$ izračunamo kot:
$$
    B[i]=\left\lfloor W\left[\left\lceil\frac{i}{w}\right\rceil\right]/2^{w-r}\right\rfloor \mod{2}.
$$
Ker besedni RAM model predpostavi, da so vse aritmetične operacije nad celimi števili, med katere sodi tudi celoštevilsko deljenje, opravljene v konstantnem času, je čas potreben za dostop do $i$-tega elementa tudi konstanten. Torej je mogoče izogniti uporabi odvečnih bitov iz naivne implementacije, ne da bi se časovna zahtevnost povečala \cite{Navarro2016}.

\paragraph{Rang:} 
Prva operacija, ki se jo lahko definira nad bitnim poljem $B$ velikosti $b$, je $rang_v(B,i)$. Operacija vrne število pojavov vrednosti $v\in\{1,0\}$ v $B$ do uključno položaja $i$. V nadaljevanju bo operacija $rang(B,i)$ predstavljala $rang_1(B,i)$. To je možno, saj velja sledeča relacija med $rang_0(B,i)$ in $rang_1(B,i)$:
\begin{equation}\label{eq:rang}
    rang_1(B,i)=i-rang_0(B,i).
\end{equation}

Operacijo se lahko naivno implenetirana s štetjem bitov z vrednostjo $1$ v bitenm polju, za kar je potrebno $O(b)$ časa. Operacijo rang se lahko pospeši na konstantni čas pri tem pa se potrebuje dodatne podatkovne strukture, ki zasedejo $o(b)$ bitov. Pri tem ni potrebno zgraditi dodatnih podatkovnih strukur za obe različici ranga, saj relacija iz enakosti \ref{eq:rang} omogoča izgradnjo podatkovne strukture zgolj za operacijo $rang_1$.

Pomožna struktura, ki omogoča konstantni čas operacije $rang(B,i)$, shranjuje range različnih elementov bitnega polja $B$ v polju $R$. Naivni pristop bi shraniv v polju $R$ range vseh elementov $B$-ja. Problem tega pristopa je prevelika prostorska zahtevnost, saj je zaželjeno, da je $R$ čim manjšin in pomožnosti ni večji od $o(b)$ bitov. Predlagana rešitev potrebuje $b\log{r_1}=O(bw)$ dodatnih bitov, pričemer $r_1$ predstavlja število bitov z vrednostjo 1 v bitnem polju $B$.

Rešitev tega problema je vzorčenje rangov, tako da so v polju $R$ shranjeni zgolj rangi nekaterih elementov $B$-ja. Polje $R$ razdeli $B$ na $s=kw$ delov, pri čemer je $k$ poljubno število. Element $R[i]=rang_1(B,is)$, pri čemer $0\le i \le \left\lfloor\frac{b}{s} \right\rfloor$. Na ta način je operacija rang implementiran kot 
\begin{equation}
    rang_1(B,i)=R\left[\left\lfloor\frac{i}{s} \right\rfloor\right] + \texttt{popcount}\left(B\left[\left\lfloor\frac{i}{s} \right\rfloor s,i\right]\right),
\end{equation}

%dopiši popcount O(1) brez cpu
kjer je \texttt{popcount} funkcija, ki prešteje število bitov z vrednostjo $1$, na danem intervalu. Zaradi uporabnosti te funkcije, je le ta že implementirana v različnih modernih arhitekturah procesorjev in je zato možno uporabiti strojno operacijo. Sicer pa je mogoče implemenitrati funkcijo \texttt{popcount} brez uporabe strojen operacije \cite{Knuth2011}. Polje $R$ ima velikost $\lfloor\frac{b}{k}\rfloor$ bitov, saj shranjuje $\lfloor\frac{b}{s}\rfloor$ števil velikosti $w$ bitov. Pri tem je potrebno funkcijo \texttt{popcount} pognati največ $k$ krat, kar naredi čas operacije rang $O(k)$ \cite{Navarro2016}.

Podobno kot polje $R$ se definira polje $R'$. Polje $R'$ hrani na $i$-tem mestu število bitov z vrednostjo $1$ po vedru $R[\left\lfloor\frac{i}{k} \right\rfloor]$ ali $R'[i]=rang_1(B,iw)-R[\left\lfloor\frac{i}{k} \right\rfloor]$. Na ta način se zniža število klicev funkcije \texttt{popcount} na 1 klic. Ker v $R'$ so sharnjena zgolj števila med 0 in $s-w$ (vsako vedro v $R$ ima $w$ elementov v $R'$), se lahko $R'$ shrani v $\lfloor\frac{b}{w}\rfloor\log{s}$ bitov, kar je $o(b)$ bitov. Tako je operacija rang implementirana s pomočjo polji $R$ in $R'$. In sicer je implementirana na sledeči način:
\begin{equation}
    rang_1(B,i)=R\left[\left\lfloor\frac{i}{kw} \right\rfloor\right]+ R'\left[\left\lfloor\frac{i}{w} \right\rfloor\right]+\texttt{popcount}\left(B\left[\left\lfloor\frac{i}{w} \right\rfloor,\left\lfloor\frac{i}{w} \right\rfloor+(i \mod w)\right]\right).
\end{equation}
Ta implementacija potrebuje konstanten čas za izračunati $rang(B,i)$. Dostop do polji $R$ in $R'$ je storjen v konstantnem času, kot tudi izračun funkcije \texttt{popcount}, ki je klicana samo enkrat\cite{Navarro2016}.

\paragraph{Izbira:}
Druga odsnovna operacija nad bitnim poljem $B$ pa je $izbira_v(B,i)$, ki vrne položaj $i$-tega pojava vrednosti $v\in\{1,0\}$ v $B$. Podobno kot operacija rang, tudi operacija izbira potrebuje pomožno podatkovno strukturo za izvedbo v konstantnem času. 

Operacijo izbira si lahko predstavimo, kot inverzno operacijo od operacije rang, saj velja relacija $j=rang_v(B,izbira_v(B,j))$. Pri tem pa ne obstaja direktna povezava med operacijo $izbira_1(B,i)$ in $izbira_0(B,i)$. To pomeni, da rešitev z pomožno podatkovno strukturo za $izbira_1(B,i)$ ne more biti uporabljena pri iskanju rešitve za $izbira_0(B,i)$. V nadaljevanju bo opisan časovno učinkovit postopek iskanja $izbire_1(B,i)$, saj se lahko $izbira_0(B,i)$ implementira na podoben način \cite{Navarro2016}.

Ko operacija izbira ni ključna pri reševanju problemov, se lahko uporabi binarno iskanje v poljih $R$ in $R'$, za kar se potrebuje $O(\log{b})$ časa. Z binarnim iskanjem se najde območje dolžine $k$, pri čemer je potrebno še dodatnih $k$ preiskav, da se najde natančno vrednost.
Čas operacije se lahko zniža na $O(\log\log b)$ z uporabo pomožnih podatkovnih struktur. Podobno kot pri operacij rang se bitno polje razdeli na $\lceil \frac{r_1}{s} \rceil$ veder, pri čemer pa je $r_1$ število bitov z vrednostjo 1 v bitnem polju in s je število takih bitov v vsakem vedru. Polje $S[0,\lceil \frac{r_1}{s} \rceil]$ hrani vrednosti $S[i]=izbira_1(B,i*s+1)$, pri čemer $S[\lceil \frac{r_1}{s} \rceil]=n+1$. Polje $S$ potrebuje $w(\lceil \frac{r_1}{s} \rceil +1)$ bitov. Ko je $s=w^2$, potem podatkovna struktura potrebuje $w(\lceil\frac{r_1}{w^2}\rceil+1)=o(r_1)=o(b)$ bitov \cite{Navarro2016}.

Vedra niso enako velika, zato se lahko razdelijo na velika vedra in mala vedra, pri čemer je vedro veliko natanko tedaj, ko je večje kot $s\log^2 n$ bitov, sicer je malo vedro. Pri tem je potrebno shraniti velikost vedra v bitno polje $V$, kjer $V[i]=1$, če $i$-to vedro je veliko, sicer je $V[i]=0$. Bitno polje $V$ potrebuje tudi dodatno podatkovno strukturo za rang. Za velika vedra se izračuna vseh $s$ vrednosti izbire, pri čemer so shranjeni v polju $I$ položaji bitov z vrednostjo ena znotraj vedra. Za mala vedra, pa se sproti naračuna izbira znotraj vedra. Operacija izbira se izračuna na sledeči način:
\begin{equation}
    izbira_1(B,j)=\left\{
    \begin{array}{rl}
       S\left[\left\lceil \frac{j}{s} -1\right\rceil\right] + I\left[rang_1(V,\left\lceil \frac{j}{s} \right\rceil)s+x\right], & V\left[\left\lceil \frac{j}{s} \right\rceil\right] = 1\\ 
       S\left[\left\lceil \frac{j}{s} -1 \right\rceil\right] + k, & V\left[\left\lceil \frac{j}{s} \right\rceil\right] = 0\\
       b+1, & m < j
    \end{array}\right.,
\end{equation}
kjer $x$ predstavlja $((j-1) \mod{s})+1$ in $k$ je položaj $((j-1) \mod{s})+1$-tega bita z vrednostjo 1 na intervalu $B\left[ S\left[\left\lceil \frac{j}{s} -1 \right\rceil\right], S\left[\left\lceil \frac{j}{s} \right\rceil-1\right]\right]$.

Polje $I$ mora shraniti $s\lceil\log n\rceil$ bitov za vsako veliko vedro, katerih je $\frac{b}{s(\log b)^2}$, torej potrebuje $O\left(\left\lceil\frac{b}{\log b}\right\rceil\right)=o(b)$ bitov. Bitno polje $V$ pa potrebuje $\lceil \frac{m}{s} \rceil$ bitov za shraniti velikosti blokov ter dodatne bite za izvajanje operacije rang v konstantnem času, torej tudi $V$ potrebuje $o(b)$ bitov \cite{Navarro2016}.

Operacija se lahko izvedene v konstantnem času. To je doseženo z dodatnim deljenjem majhnih veder, na podoben način, kot je bilo to storjeno nad celotnim bitnim poljem $B$. Vsako majhno vedro se dodatno razdeli na $s'=(\log\log b)^2$ mini veder, pri čemer mini vedro je veliko, ko je večje od $s'(\log\log b)^2$. Vsako majhno mini vedro potrebuje $s'\log{(s(\log{b})^2)}=O((\log\log b)^3)=o(b)$ bitov ter vsako veliko mini vedro potrebuje isto prostora, pri čemer pa jih je največ $O\left(\frac{b}{(\log\log b)^4}\right)$, torej vsa velika mini vedra skupaj potrebujejo $O\left(\frac{b}{\log\log b}\right) =o(b)$ bitov \cite{Navarro2016}.


Vse dodatne podatkovne strukture potrebne za izvajanje operacij rang in izbira v konstantnem času, so lahko izgrajene v dveh sprehodih po bitnem polj $B$, pri čemer vsak sprehod traja $O(b)$ časa. Pri tem je ves potrebni spomin že predhodno dodeljen.

\paragraph{Predhodnik/Naslednjik:}
S pomočjo operaciji rang in izbira se lahko implementira dodatne operacije, ki omogočajo lažje iskanje po bitnem polju $B$. Dve taki operaciji, ki bosta uporabljeni za implementacijo operacij nad drevesi, sta predhodnik in naslednik.

Operacija predhodnik elementa $y$ najde ideks $x_i$ del zaporedja indeksov bitov z vrednostjo $v$, za katerega velja $x_i \le y < x_{i+1}$ in $1\le i\le r_v$, kjer je $r_v$ število ponovitev $v$-ja v $B$. Operacija je implementirana kot
    $$predhodnik_v(B,y)=izbira_v(B,rang_v(B,y)),$$
pri čemer je $v\in \{0,1\}$. Na podoben način se definirana tudi operacijo naslednik. Operacija naslednik elementa $y$ najde položaj elementa $x_i$ del zaporedja indeksov bitov z vrednostjo $v$, pri čemer velja, da $x_{i-1}< y \le x_i$. Pri tem je operacija implementirana kot
    $$naslednik_v(B,y)=izbira_v(B,rang_v(B,y-1)+1),$$
kjer je  $v\in \{1,0\}$ \cite{Navarro2016}.

Operaciji se uporablja za sprehod po bitnem polju $B$. Z njima se lahko najde indekse vseh bitov z vrednostjo $v$ v $O(r_v)$ časa ($r_v$ je število bitov z vrednostjo $v$ v bitnem polj $B$).

\paragraph{Operacije na intervalih??:}
Dosedaj so vse predstavljene operacije imele kot vhod zgolj en element v bitnem polju, ampak nekateri problemi zahtevajo rešitev za podani interval. Pogosta vprašanja na intervalih sta največje ali najmanjše število v intervalu. Na bitnih poljih, pa se ta problem pretvori na razliko med številom bitov z vrednostjo 0 ter številom bitov z vrednostjo 1 do $i$-tega bita. To razmerje imenujemo \textit{višek}$(B,i)$ in je je izračunan, kot:
$$
    \textit{višek}(B,i)=rang_0(B,i)-rang_1(B,i)=2rang_0(B,i)-i.
$$
Na podoben način se lahko definira tudi višek na intervalu med indeksom $i$ in $j$, in sicer kot:
$$
    \textit{višek}(B,i,j)=\textit{višek}(B,j)-\textit{višek}(B,i-1).
$$

Prva operacija na intervalih je $rmq(B,i,j)$ (angl. \textit{range minimum query}), ki vrne indeks $k$, za katerega velja, da je $i\le k\le j$ in \textit{višek}$(B,k)$ je najnižji višek na intervalu med $i$ in $j$ ter se najnižji višek prvič pojavi na indeksu $k$. Podobno je definirana tudi operacija $rMq(B,i,j)$ (angl. \textit{range maximum query}), ki pa vrne indeks $k$, pri čemer je $i\le k\le j$ in $vi$\textit{š}$ek(B,k)$ je najvišji višek na intervalu med $i$ in $j$ ter se najvišji višek prvič pojavi na indeksu $k$. Operacija $minizbira(B,i,j,t)$ vrne položaj $t$-tega pojava najmanjšega viška na intervalu med $i$ in $j$. Operacija $min$\textit{š}$tetje(B,i,j)$ pa vrne število pojav najnižjega viška na intervalu med $i$ in $j$ \cite{Navarro2016}.

Vse predstavljene operacije na intervalih (razen operacije \textit{višek}, ki potrebuje konstanten časa) so lahko implementirane s časovno zahtevnostjo $O(\log{b})$. Pri tem pa je potrebno zgraditi dodatno podatkovno strukturo rmM-drevo (angl. \textit{range minumum maximum tree}), ki se je lahko shranjeno z $O(b/\log{b})=o(b)$ dodatnimi biti. Podatkovna struktura razdeli bitno polje $B$ na $\frac{b}{a}$ veder velikosti $a$ elementov ter se za vsako vedro ustvari list rmM-drevesa. Drevo je levo poravnano in se lahko zapiše kot polje vozlišč (podobno kot podatkovna struktura kopica). Torej so otroci $i$-tega vozlišča na $2i$-tem in $(2i+1)$-vem mestu v polju ter starš $i$-tega vozlišča se nahaja na $\left\lfloor\frac{i}{2}\right\rfloor$-mestu. Vsako vozlišče v drevesu hrani štiri podatke: $e$ relativni višek pokritega intervala, $m$ najmanjši relativni višek v območju, $M$ največji relativni višek na območju in $n$ število najmanjših viškov na pokritem intervalu. Pri tem vozlišče pokriva celotno območje, ki ga pokrivata oba otroka, in listi pokrivajo zgolj eno vedro velikosti $a$ elementov. Torej koren drevesa pokriva celotno bitno polje $B$. Vse predstavljene operacije so implementirane s pomočjo sprehoda po rmM-drevesu \cite{Navarro2016}.

Vse štiri operacije temelijo na sprehodu po rmM-drevesu, torej bo sprehod predstavljen zgolj za operacijo $rmq(B,i,j)$ na intervalu bitenga polja $B[i,j]$. Operacija $rmq(B,i,j)$ je storjena v dveh korakih. Prvi korak je iskanje vrednost najmanjšega viška na intervalu $B[i,j]$. Ker se lahko $i$ nahaja sredi vedra bitov, se ročno naračuna relativni višek $d$ ter najnižji višek na intervalu $m$ med $i$ in začetkom vedra $\lceil i/a\rceil$. Če je $j$ med $i$ in začetkom vedra  $\lceil i/a\rceil$, se izračuna zgolj do $j$-tega bita in $m$ predstavlja tudi najnižji višek na intervalu med $i$ in $j$, zakar potrebujemo $O(a)$ časa. Sicer pa se nadaljuje s sprehodom po $rmM$-drevesu. Začetno vozlišče spehoda je list, ki predstavlja vedro  $\lceil i/a\rceil$, in ga označimo z $v$. Izračunamo tudi zaporedno število lista, ki vusebuje vedro z koncem inervala $j$, in ga označimo kot $k$. Zdej lahko začnemo z sprehodom po drevsu navzgor. Če je $v$ desni otrok ($v$ je sodo število), se premaknemo v straša, torej $v\leftarrow (v-1)/2$. Sicer pa je potrebno preveriti, ali je desni brat tudi v intervalu, kar se lahko preveri, tako da prevrimo, če trditev $\lfloor l/2^{\lfloor \log l\rfloor- \lfloor \log u \rfloor}\rfloor\ne u$ drži, potem je vozlišče $u$ tudi znoraj intervala $B[i,j]$. Če je desni brat v intervalu prevrimoimo, ali smo našli nov najmanjši višek na intervalu ($m>d+rmM[v+1].m$). Če smo ga našli potem $m\leftarrow d+rmM[v+1].m$. Nato pa se še poravi višek intervala na $d\leftarrow d+rmM[v+1].e$. Zatem pa se premaknemo v starša, torej $v\leftarrow v/2$ \cite{Navarro2016}.

Ko desni brat ni v intervalu, torej ne velja prejšni pogoj, pa nadaljujemo z sprehodmo navzdol iz našega desnega brata $v\leftarrow (v+1)/2$. Tokrat pa preverjamo, ali je levi otrok vsebovan v intervalu ter če vozlišče $v$ omogoča zmanjševanje najmanjšega viška. Če vozlišče $v$ ne omogoča zmanjševanja lahko sprehod končamo in vemo, da najmanjši višek je $m$, sicer pa nadaljujemo s sprehodom. Če levi otrok ni vsebovan nadaljujemo z sprehodom v levem otroku, sicer pa prevrimo, če velja $m>d+rmM[2v].m$ ter popravimo vrednos $m$,če velja. Nato popravimo vrednos $d\leftarrow d+rmM[2v].e$ ter nadaljujemo z iskanjem v desnem otroku $v\leftarrow 2v+1$. Sprehod nadaljujemo dokler ne dosežemo listov oziroma $v>\lceil n/a\rceil$. Če list $v$ ne omogoča zmanjevanja najmanjše vrednosti viška na intervalu oziroma $m\le d+rmM[v].m$, potem je $m$ najmanjši višek na intervalu. Sicer pa pregledamo, na podoben način kot pred začetkom iskanja, še višek do $j$-tega bita in najmanjši višek na tem inervalu označimo $m'$. Če $m>d+m'$ potem je najmanjši višek na intervalu $B[i,j]$ enak $d+m'$, sicer pa je $m$ \cite{Navarro2016}. 

Zadnji korak pa je iskanje točnega indeksa bita z relativnim viškom $m$. To je storjeno z operacijo \textit{IskanjeNaprej}$(B,i,m)$, ki najde prvi $j> i$, za katerega velja \textit{višek}$(B,j)=\textit{višek}(B,i)+m$. Operacija je implementirana na isti način, samo tokrat se ne preverja vrednos polja $R[v].m$, ampak se išče prvo pojavitev viška, ki je enaka $m$. Ta isti  postopek se lahko uporabi tudi za preostale tri operacije, pri čemer pa operacija $rMq(B,i,j)$ uporablja namesto polja $rmM[v].m$ polje $rmM[v].M$ in relacija manjše postane večje in obratno. Operaciji \textit{minIzbira}$(B,i,j,t)$ in \textit{minŠtetje}$(B,i,j)$, pa uporablajta polje $rmM[v].n$\cite{Navarro2016}.

Tako implementirane operacije potrebujejo $O(\log{b})$ časa, da se izvršijo. Začetno in končno štetje bitov potrebuje $O(a)=O(1)$ čas. Ker je $rmM$-drevo dvojiško in polno (vsak globina drevesa, razen zadnje, ima maksimalno število otrok),  je višina drevesa enaka $O(\log{\lceil b/a\rceil})=O(\log{b})$, torej tudi sprehod potrebuje, ki gredo od lista proti korenu ali od korena proti listu, potrebujejo $O(\log{b})$ časa. Z izdelavo manjših $rmM$-dreves, ki zavzamejo $\beta=\log^3{b}$ elementov, in dodatne podatkovne strukture imenovane pospeševalnik (angl. \textit{accelerator})je možmo implementirati te operacije v času $O(\log\log{b})$ \cite{Navarro2016}.