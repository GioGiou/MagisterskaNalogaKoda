Pogosti problem pri obdelavi daljših besedah je iskanje vzorcev v njih. V procesiranju naravnih jezikov se ta problem pretvori na iskanje vseh ponovitev besede v besedilu. Medtem ko se v bioinformatiki ta problem pretvori na preverjanje prisotnost specifičnih genov ali drugih DNK sekvenc v genomu. 

Ko v besedi $T$ dolžine $n$ iščemo zgolj en vzorec $P$ dolžine $m$, se za iskanje lahko uporabi Knuth–Morris–Pratt (KMP) algoritem, s časovno zahtevnostjo $O(n+m)$.  V primeru, da se v besedi išče več vzorcev, je smiselno nad besedo zgraditi indeks recimo priponsko drevo, ki je lahko zgrajeno v času $O(n)$, in nato iskati vzorce. Časovna zahtevnost iskanja vzorca v priponskem drevesu je sorazmerna dolžini vzorca, $O(m)$. Ko je vzorec prisoten v besedi, se vsaj ena pripona besede začne z iskanim vzorcem. 
Torej se vzorec zagotovo nahaja na začetku sprehoda iz korena proti listom priponskega drevesa, zgrajenega nad besedo. 
Peter Weiner je kot prvi predstavil priponska drevesa leta 1973 \cite{Weiner1973} in jih uporabil v algoritmu za iskanje vzorcev v besedilu. Časovna zahtevnost podanega algoritma je $O(m)$. Velikost priponskega drevesa je sorazmerna z velikostjo besede, torej pri velikih besedah preraste velikost delovnega spomina, kar močno vpliva na hitrost iskanja. Rešitev te težave je kompaktna predstavitev priponskega drevesa \cite{Navarro2016}.

Namen magistrske naloge je preučevanje vpliva kompaktne predstavitve na izgradnjo priponskih dreves in na operacije nad njimi. V nalogi bodo predstavljene  časovne zahtevnosti osnovnih operacij kot tudi empirična primerjava različnih implementacij priponskih dreves.

\section{STRUKTURA}\label{sec:struktura}

Magistrska naloga je razdeljena na tri dele. V drugem poglavju naloge bo podrobno predstavljena podatkovna struktura priponsko drevo (angl. \textit{Suffix Tree} oziroma ST). Poleg predstavitve strukture bo v poglavju prikazana tudi metoda, ki sprotno zgradi priponsko drevo v času $O(n)$.

%\newpage

V tretjem poglavju bo predstavljena podatkovna struktura kompaktno priponsko drevo (angl. \textit{Compressed Suffix Tree} oziroma CST), ki omogoča iste operacije kot priponsko drevo, pri tem pa potrebuje manj prostora. V tem poglavju bodo tudi prikazane različne kompaktne prestavitve dreves in algoritem za izgradnjo kompaktnega priponskega drevesa, ki skozi celotno izgradnjo ohranja kompaktnost podatkovne strukture.

V četrtem poglavju bodo predstavljene vse operacije nad priponskimi drevesi. Prikazana bo teoretična primerjava različnih implementacij. Pri tem bo izdelana tudi empirična primerjava implementaciji priponskih dreves, ki bo merila prostorsko in časovno zahtevnost.